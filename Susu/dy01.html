<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AR Áà±ÂøÉÁÖßÁâáÈ¶Ü</title>
    <style>
        body { margin: 0; padding: 0; background-color: #000; overflow: hidden; font-family: 'Microsoft YaHei', 'Arial', sans-serif; user-select: none; }
        
        #input_video { 
            position: absolute; top: 0; left: 0; 
            width: 100%; height: 100%; 
            object-fit: cover; 
            transform: scaleX(-1); 
            z-index: 0; 
            filter: brightness(0.6) contrast(1.2) saturate(1.2); 
        }

        #vignette-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1; pointer-events: none;
            background: radial-gradient(circle, rgba(0,0,0,0) 30%, rgba(0,0,0,0.9) 100%);
        }

        canvas { 
            display: block; position: absolute; top: 0; left: 0; 
            z-index: 2; pointer-events: none;
        }
        
        #bottom-left-panel {
            position: absolute; bottom: 30px; left: 30px; 
            z-index: 20; pointer-events: auto;
        }
        
        .upload-btn {
            display: flex; align-items: center; justify-content: center;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 30px;
            color: #fff;
            font-size: 14px;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.2s ease;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .upload-btn:hover {
            border-color: #ff00ff;
            box-shadow: 0 0 15px #ff00ff;
            background: rgba(255, 0, 255, 0.3);
        }
        #imageInput { display: none; }

        #sleep-overlay {
            position: absolute; top: 50%; left: 50%; 
            transform: translate(-50%, -50%);
            z-index: 15; text-align: center;
            transition: opacity 0.5s;
            width: 100%; pointer-events: none;
        }
        #sleep-text {
            color: rgba(255, 255, 255, 0.95);
            font-size: 36px; font-weight: bold;
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
            letter-spacing: 4px;
            margin-bottom: 40px;
        }

        .swipe-track {
            width: 400px; height: 4px; background: rgba(255,255,255,0.1);
            margin: 0 auto; border-radius: 2px; position: relative; overflow: hidden;
        }
        .swipe-bar {
            position: absolute; left: 0; top: 0; height: 100%; width: 0%;
            background: linear-gradient(90deg, transparent, #00ffff, #fff);
            box-shadow: 0 0 20px #00ffff;
            transition: width 0.05s linear; /* ËøõÂ∫¶Êù°ÂèçÂ∫îÊõ¥Âø´ */
        }

        #ui-layer { 
            position: absolute; top: 20px; left: 20px; z-index: 10; 
            background: rgba(0, 0, 0, 0.5); padding: 15px; 
            border-radius: 12px; color: white; pointer-events: auto; 
            backdrop-filter: blur(5px); border: 1px solid rgba(255, 255, 255, 0.2); 
            max-width: 260px; 
            opacity: 0; transition: opacity 0.8s; 
            pointer-events: none;
        }
        
        #status-text { margin-top:5px; color:#ff69b4; font-size:14px; height:20px; font-weight:bold; text-align:center; text-shadow: 0 0 5px #ff00ff; }
        
        #debug-info { margin-top: 8px; padding: 4px 8px; background: rgba(255,255,255,0.1); border-radius: 4px; font-size: 12px; display: flex; justify-content: space-between; align-items: center; }
        .state-tag { padding: 2px 6px; border-radius: 3px; font-weight: bold; font-size: 12px;}
        .state-active { background: #ff0055; color: white; box-shadow: 0 0 10px #ff0055;} 
        .state-idle { background: #00ccff; color: white; box-shadow: 0 0 10px #00ccff;}   
        
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #00ffff; font-size: 20px; z-index: 30; font-weight: bold; pointer-events: none;}
    </style>
    <!-- ÂºïÂÖ• MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">Ê≠£Âú®Ê†°ÂáÜÈõ∂Âª∂ËøüÂºïÊìé...</div>

    <div id="bottom-left-panel">
        <label for="imageInput" class="upload-btn" id="upload-label">
            <span style="margin-right:8px">üìÅ</span> ÂØºÂÖ•ÁÖßÁâá
        </label>
        <input type="file" id="imageInput" multiple accept="image/*">
    </div>

    <div id="sleep-overlay">
        <div id="sleep-text">ËØ∑Âî§ÈÜí</div>
        <div class="swipe-track">
            <div class="swipe-bar" id="swipe-bar"></div>
        </div>
    </div>

    <div id="ui-layer">
        <h3 style="margin:0 0 10px 0; color:#00ffff; text-shadow: 0 0 5px #00ffff;">AR ÁÖßÁâáÈ¶Ü</h3>
        <div id="debug-info">
            <span>Âè≥ÊâãÁä∂ÊÄÅ: </span>
            <span id="hand-state" class="state-tag state-idle">ÂØªÊâæÊâãÂäø</span>
        </div>
        <div id="status-text"></div>
        <div style="margin-top:10px; font-size:12px; color:#ccc; line-height: 1.6;">
            1. Â∑¶ÊâãÊè°Êã≥: Áà±ÂøÉ | Âº†ÂºÄ: ÁîªÂªä<br>
            2. Âè≥ÊâãÈ£üÊåá: ÊéßÂà∂ÂÖâÊ†á<br>
            3. <b>ÊÇ¨ÂÅú 0.5Áßí</b>: ÊâìÂºÄÁÖßÁâá
        </div>
    </div>

    <video id="input_video"></video>
    <div id="vignette-overlay"></div>
    <canvas id="output_canvas"></canvas>

<script>
    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d', { alpha: true, desynchronized: true });
    
    const loadingDiv = document.getElementById('loading');
    const uiLayer = document.getElementById('ui-layer');
    const sleepOverlay = document.getElementById('sleep-overlay');
    const uploadLabel = document.getElementById('upload-label');
    const swipeBar = document.getElementById('swipe-bar');
    const fileInput = document.getElementById('imageInput');
    const statusText = document.getElementById('status-text');
    const handStateTag = document.getElementById('hand-state');

    const PARTICLE_COUNT = 800; 
    const SNAP_DISTANCE = 70; 
    const HOVER_REQUIRED_TIME = 500; 

    const SWIPE_START_ZONE = 0.25; 
    const SWIPE_END_ZONE = 0.65;   
    const SWIPE_TIMEOUT = 1200;    

    const STATE = {
        IS_SLEEPING: true,
        WAKE_ANIMATION: 0,
        MODE: 'HEART',
        LEFT_HAND_GESTURE: 'FIST',
        
        RIGHT_HAND: { 
            detected: false, 
            x: -100, y: -100,      // Âπ≥ÊªëÂêéÁöÑÂùêÊ†á
            rawX: -100, rawY: -100 // ÂéüÂßãÂùêÊ†á
        },
        
        SWIPE: { isReady: false, lastReadyTime: 0, maxProgress: 0 },
        HOVERED_PARTICLE: null,      
        DWELL_START_TIME: 0,         
        DWELL_PROGRESS: 0,           
        SHOWING_PHOTO_DATA: null     
    };

    const particles = [];

    class Particle {
        constructor(index) {
            this.index = index;
            this.isEdge = Math.random() < 0.25;
            this.reset();
            this.z = 0.5 + Math.random(); 

            const isPink = Math.random() > 0.5;
            const hue = isPink ? (300 + Math.random() * 40) : (170 + Math.random() * 40);
            
            this.colorStr = `hsla(${hue}, 100%, 70%, ${0.6 * this.z})`; 
            this.activeColorStr = `hsla(${hue}, 100%, 95%, 1)`; 
            this.edgeGlowColor = `hsla(${hue}, 100%, 80%, 0.4)`;

            this.baseSize = (Math.random() * 2 + 1.5) * this.z; 
            this.size = this.baseSize;
            this.isPhoto = false;
            this.photoData = null; 
            this.label = "";
            this.noiseOffset = Math.random() * 1000;
        }

        reset() {
            this.x = Math.random() * window.innerWidth;
            this.y = Math.random() * window.innerHeight;
            this.tx = this.x; this.ty = this.y;
            this.heartTarget = { x: 0, y: 0 };
            this.galleryBase = { x: 0, y: 0 };
            
            this.floatOffset = Math.random() * 100; 
            this.floatSpeed = 0.3 + Math.random() * 0.7; 
            this.floatRange = 5 + Math.random() * 20;
        }

        update(time) {
            let targetX, targetY;
            let ease = 0.15;
            const noiseX = Math.sin(time + this.noiseOffset) * 2;
            const noiseY = Math.cos(time + this.noiseOffset * 0.9) * 2;

            if (STATE.MODE === 'HEART') {
                const beat = 1 + Math.sin(time * 3) * 0.05; 
                const cx = window.innerWidth / 2;
                const cy = window.innerHeight / 2;
                targetX = cx + (this.heartTarget.x - cx) * beat + noiseX;
                targetY = cy + (this.heartTarget.y - cy) * beat + noiseY;
                if (this.isEdge) ease = 0.2; 
            } else {
                if (this.isPhoto) {
                    targetX = this.galleryBase.x;
                    targetY = this.galleryBase.y;
                } else {
                    targetX = this.galleryBase.x + Math.sin(time * this.floatSpeed + this.floatOffset) * this.floatRange;
                    targetY = this.galleryBase.y + Math.cos(time * this.floatSpeed + this.floatOffset) * this.floatRange;
                }
            }
            this.tx = targetX; this.ty = targetY;
            this.x += (this.tx - this.x) * ease;
            this.y += (this.ty - this.y) * ease;
        }

        draw(ctx, isHovered) {
            if (STATE.IS_SLEEPING) return;
            
            let globalAlpha = STATE.WAKE_ANIMATION < 1 ? STATE.WAKE_ANIMATION : 1;
            ctx.globalAlpha = globalAlpha;

            if (STATE.MODE === 'GALLERY' && this.isPhoto) {
                let renderSize = this.size * 6; 
                ctx.beginPath();
                if (isHovered) {
                    renderSize = this.size * 9; 
                    ctx.fillStyle = '#ffffff'; 
                    // Âè™ÊúâËøôÈáåÁî® shadowBlurÔºå‰∏çÂç°
                    ctx.shadowBlur = 30; ctx.shadowColor = '#ffffff';
                } else {
                    ctx.fillStyle = this.activeColorStr;
                    ctx.shadowBlur = 0; 
                }
                ctx.arc(this.x | 0, this.y | 0, renderSize, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.save();
                ctx.globalAlpha = globalAlpha; 
                ctx.fillStyle = "white";
                ctx.shadowColor = isHovered ? "#ff00ff" : "black"; 
                ctx.shadowBlur = isHovered ? 8 : 4;
                ctx.font = isHovered ? "bold 15px Microsoft YaHei" : "11px Microsoft YaHei";
                ctx.textAlign = "center";
                ctx.fillText(this.label, this.x, this.y + renderSize + 18);
                ctx.restore();
                ctx.shadowBlur = 0; 
            } else {
                ctx.beginPath();
                if (STATE.MODE === 'HEART' && this.isEdge) {
                    // ‰º™ÂÖâÊôïÁªòÂà∂Ê≥ï
                    ctx.fillStyle = this.edgeGlowColor; 
                    ctx.arc(this.x | 0, this.y | 0, this.size * 2.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.fillStyle = '#ffffff'; 
                    ctx.arc(this.x | 0, this.y | 0, this.size, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    ctx.fillStyle = this.colorStr;
                    ctx.shadowBlur = 0; 
                    ctx.arc(this.x | 0, this.y | 0, this.size, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            ctx.globalAlpha = 1;
        }
    }

    function drawRippleCursor(ctx, x, y, isHovering, isOpening) {
        const now = Date.now();
        const color = isOpening ? '#ff0055' : '#00ffff'; 
        ctx.save();
        ctx.translate(x, y);

        // ÂÖâÊ†áÊ†∏ÂøÉ
        ctx.shadowBlur = 15; ctx.shadowColor = color; ctx.fillStyle = color;
        ctx.beginPath(); ctx.arc(0, 0, 6, 0, Math.PI * 2); ctx.fill();

        if (!STATE.SHOWING_PHOTO_DATA) {
            ctx.shadowBlur = 0; ctx.strokeStyle = color;
            for(let i=0; i<2; i++) {
                const t = ((now / 1500) + (i * 0.5)) % 1; 
                const radius = 6 + t * 30; 
                const alpha = 1 - t; 
                ctx.globalAlpha = alpha * 0.8; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(0, 0, radius, 0, Math.PI * 2); ctx.stroke();
            }
        }

        if (STATE.DWELL_PROGRESS > 0 && STATE.DWELL_PROGRESS < 1) {
            ctx.globalAlpha = 1; ctx.shadowBlur = 5; ctx.shadowColor = '#fff';
            ctx.strokeStyle = '#ffffff'; ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(0, 0, 20, -Math.PI/2, -Math.PI/2 + (Math.PI * 2 * STATE.DWELL_PROGRESS));
            ctx.stroke();
        }
        ctx.restore();
    }

    function initParticles() {
        canvasElement.width = window.innerWidth;
        canvasElement.height = window.innerHeight;
        particles.length = 0;
        for (let i = 0; i < PARTICLE_COUNT; i++) particles.push(new Particle(i));

        const cx = window.innerWidth / 2;
        const cy = window.innerHeight / 2;

        particles.forEach((p) => {
            const t = Math.random() * Math.PI * 2;
            const scale = 18; 
            const hx = 16 * Math.pow(Math.sin(t), 3);
            const hy = -(13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
            let len = p.isEdge ? (0.98 + Math.random() * 0.04) : (Math.sqrt(Math.random()) * 0.95); 
            p.heartTarget.x = cx + hx * scale * len;
            p.heartTarget.y = cy + hy * scale * len;
            p.galleryBase.x = Math.random() * window.innerWidth;
            p.galleryBase.y = Math.random() * window.innerHeight;
        });
        recalculatePhotos();
    }

    function recalculatePhotos() {
        const w = window.innerWidth; const h = window.innerHeight;
        particles.filter(p => p.isPhoto).forEach(p => {
            p.galleryBase.x = w/2 + (Math.random() - 0.5) * w * 0.7;
            p.galleryBase.y = h/2 + (Math.random() - 0.5) * h * 0.7;
        });
    }

    function wakeUpSystem() {
        if (!STATE.IS_SLEEPING) return;
        STATE.IS_SLEEPING = false;
        sleepOverlay.style.opacity = '0';
        uiLayer.style.opacity = '1';
        STATE.WAKE_ANIMATION = 0; 
        particles.forEach(p => {
            p.x += (Math.random() - 0.5) * 300;
            p.y += (Math.random() - 0.5) * 300;
        });
    }

    function checkSwipeGesture(cursorX, cw) {
        if (!STATE.IS_SLEEPING) return;
        const xRatio = cursorX / cw; 
        const now = Date.now();
        if (xRatio < SWIPE_START_ZONE) {
            STATE.SWIPE.isReady = true;
            STATE.SWIPE.lastReadyTime = now;
            STATE.SWIPE.maxProgress = 0; 
        }
        if (STATE.SWIPE.isReady) {
            if (now - STATE.SWIPE.lastReadyTime > SWIPE_TIMEOUT) {
                STATE.SWIPE.isReady = false;
                swipeBar.style.width = "0%";
                return;
            }
            let progress = (xRatio - SWIPE_START_ZONE) / (SWIPE_END_ZONE - SWIPE_START_ZONE);
            progress = Math.max(0, Math.min(1, progress));
            if (progress > STATE.SWIPE.maxProgress) STATE.SWIPE.maxProgress = progress;
            swipeBar.style.width = (STATE.SWIPE.maxProgress * 100) + "%";
            if (xRatio > SWIPE_END_ZONE) wakeUpSystem();
        }
    }

    function onResults(results) {
        loadingDiv.style.display = 'none';

        STATE.RIGHT_HAND.detected = false;
        let leftHandFound = false;

        if (results.multiHandLandmarks && results.multiHandedness) {
            for (let i = 0; i < results.multiHandLandmarks.length; i++) {
                const label = results.multiHandedness[i].label;
                const lm = results.multiHandLandmarks[i];

                if (label === 'Right' && !STATE.IS_SLEEPING) { 
                    leftHandFound = true;
                    const wrist = lm[0];
                    const tips = [8, 12, 16, 20];
                    const pips = [6, 10, 14, 18];
                    let folded = 0;
                    for(let k=0; k<4; k++) {
                        if (Math.hypot(lm[tips[k]].x - wrist.x, lm[tips[k]].y - wrist.y) < 
                            Math.hypot(lm[pips[k]].x - wrist.x, lm[pips[k]].y - wrist.y) * 0.9) folded++;
                    }
                    STATE.LEFT_HAND_GESTURE = folded >= 3 ? 'FIST' : 'OPEN';
                }

                if (label === 'Left') {
                    STATE.RIGHT_HAND.detected = true;
                    const cw = canvasElement.width;
                    const ch = canvasElement.height;
                    const cursorX = (1 - lm[8].x) * cw;
                    const cursorY = lm[8].y * ch;
                    STATE.RIGHT_HAND.rawX = cursorX;
                    STATE.RIGHT_HAND.rawY = cursorY;

                    if (STATE.IS_SLEEPING) checkSwipeGesture(cursorX, cw);
                }
            }
        }
        
        if (!STATE.IS_SLEEPING) {
            if (!leftHandFound) STATE.LEFT_HAND_GESTURE = 'FIST';
            STATE.MODE = (STATE.LEFT_HAND_GESTURE === 'FIST') ? 'HEART' : 'GALLERY';
        }
    }

    // Áã¨Á´ãÁöÑÊ∏≤ÊüìÂæ™ÁéØ (Ëß£ËÄ¶ FPS)
    function renderLoop() {
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
        
        // 1. ËÆæÁΩÆÊ∑∑ÂêàÊ®°Âºè
        if (!STATE.IS_SLEEPING) {
            if (STATE.WAKE_ANIMATION < 1) {
                STATE.WAKE_ANIMATION += 0.04; 
                if(STATE.WAKE_ANIMATION > 1) STATE.WAKE_ANIMATION = 1;
            }
            canvasCtx.globalCompositeOperation = 'lighter';
        } else {
            canvasCtx.globalCompositeOperation = 'source-over';
        }

        // --- Ê†∏ÂøÉ‰øÆÊîπÔºöÈõ∂Âª∂ËøüÈÄªËæë ---
        if (STATE.RIGHT_HAND.detected) {
            const dx = STATE.RIGHT_HAND.rawX - STATE.RIGHT_HAND.x;
            const dy = STATE.RIGHT_HAND.rawY - STATE.RIGHT_HAND.y;
            const dist = Math.hypot(dx, dy);

            // Â¶ÇÊûúË∑ùÁ¶ªË∂ÖËøá 3ÂÉèÁ¥† (‰∏ªÂä®ÁßªÂä®)ÔºåÁõ¥Êé•Áû¨ÁßªÔºåÊ∂àÈô§Âª∂Ëøü
            if (dist > 3) {
                STATE.RIGHT_HAND.x = STATE.RIGHT_HAND.rawX;
                STATE.RIGHT_HAND.y = STATE.RIGHT_HAND.rawY;
            } else {
                // Â¶ÇÊûúÊòØÊûÅÂ∞èÁöÑÂæÆÈ¢§Ôºå‰ΩøÁî®Âπ≥ÊªëÈò≤Ê≠¢ÊäñÂä®
                STATE.RIGHT_HAND.x += dx * 0.3;
                STATE.RIGHT_HAND.y += dy * 0.3;
            }
        }

        // 3. Êõ¥Êñ∞‰∏éÁªòÂà∂Á≤íÂ≠ê
        const time = Date.now() / 1000;
        particles.forEach(p => {
            p.update(time);
            p.draw(canvasCtx, p === STATE.HOVERED_PARTICLE && !STATE.IS_SLEEPING);
        });

        canvasCtx.globalCompositeOperation = 'source-over'; 

        // 4. ‰∫§‰∫íÈÄªËæë
        if (!STATE.IS_SLEEPING && STATE.MODE === 'GALLERY' && STATE.RIGHT_HAND.detected) {
            const cursor = { x: STATE.RIGHT_HAND.x, y: STATE.RIGHT_HAND.y };
            const now = Date.now();
            
            let bestCandidate = null; let minD = 9999;
            for (let p of particles) {
                if (!p.isPhoto) continue;
                const d = Math.hypot(p.x - cursor.x, p.y - cursor.y);
                if (d < minD) { minD = d; bestCandidate = p; }
            }

            if (bestCandidate && minD < SNAP_DISTANCE) {
                if (STATE.HOVERED_PARTICLE !== bestCandidate) {
                    STATE.HOVERED_PARTICLE = bestCandidate;
                    STATE.DWELL_START_TIME = now;
                    STATE.DWELL_PROGRESS = 0;
                }
                
                if (!STATE.SHOWING_PHOTO_DATA) {
                    const elapsed = now - STATE.DWELL_START_TIME;
                    STATE.DWELL_PROGRESS = Math.min(1, elapsed / HOVER_REQUIRED_TIME);
                    
                    if (STATE.DWELL_PROGRESS >= 1) {
                        STATE.SHOWING_PHOTO_DATA = STATE.HOVERED_PARTICLE.photoData;
                        handStateTag.innerText = "Â∑≤ÊâìÂºÄ"; handStateTag.className = "state-tag state-active";
                    } else {
                        statusText.innerText = "Âç≥Â∞ÜÊâìÂºÄ...";
                        handStateTag.innerText = "ÊÇ¨ÂÅú‰∏≠"; handStateTag.className = "state-tag state-idle";
                    }
                }
            } else {
                STATE.HOVERED_PARTICLE = null;
                STATE.DWELL_PROGRESS = 0;
                STATE.DWELL_START_TIME = 0;
                STATE.SHOWING_PHOTO_DATA = null;
                statusText.innerText = "";
                handStateTag.innerText = "ÁßªÂä®"; handStateTag.className = "state-tag state-idle";
            }
            drawRippleCursor(canvasCtx, cursor.x, cursor.y, STATE.HOVERED_PARTICLE !== null, STATE.SHOWING_PHOTO_DATA !== null);
        } 
        else if (STATE.IS_SLEEPING && STATE.RIGHT_HAND.detected) {
            drawRippleCursor(canvasCtx, STATE.RIGHT_HAND.x, STATE.RIGHT_HAND.y, STATE.SWIPE.isReady, false);
        }

        if (STATE.SHOWING_PHOTO_DATA) {
            const data = STATE.SHOWING_PHOTO_DATA;
            const img = data.img;
            const w = window.innerWidth; const h = window.innerHeight;
            
            canvasCtx.fillStyle = "rgba(0,0,0,0.9)"; canvasCtx.fillRect(0, 0, w, h);
            
            const maxW = w * 0.85; const maxH = h * 0.85;
            const ratio = Math.min(maxW / img.width, maxH / img.height);
            const dw = img.width * ratio; const dh = img.height * ratio;
            const dx = (w - dw)/2; const dy = (h - dh)/2;
            
            canvasCtx.strokeStyle = "#ff00ff"; canvasCtx.lineWidth = 4; 
            canvasCtx.strokeRect(dx, dy, dw, dh);
            canvasCtx.drawImage(img, dx, dy, dw, dh);
            
            canvasCtx.fillStyle = "white"; canvasCtx.font = "bold 28px Microsoft YaHei"; 
            canvasCtx.textAlign = "center";
            canvasCtx.fillText(STATE.HOVERED_PARTICLE.label, w/2, dy + dh + 45);
        }

        requestAnimationFrame(renderLoop);
    }

    initParticles();
    window.addEventListener('resize', () => { canvasElement.width = window.innerWidth; canvasElement.height = window.innerHeight; initParticles(); });
    
    fileInput.addEventListener('change', (e) => {
        const files = e.target.files; if (!files.length) return;
        uploadLabel.innerHTML = `<span style="margin-right:8px; color:#00ff00">‚úÖ</span> Â∑≤ÂØºÂÖ• ${files.length} Âº†`;
        uploadLabel.style.borderColor = "#00ff00";

        particles.forEach(p => { p.isPhoto = false; p.photoData = null; p.label = ""; }); 
        
        Array.from(files).forEach((file, i) => {
            const reader = new FileReader();
            reader.onload = (evt) => {
                const img = new Image(); img.src = evt.target.result;
                img.onload = () => {
                    let fileName = file.name;
                    const lastDotIndex = fileName.lastIndexOf('.');
                    if (lastDotIndex !== -1) fileName = fileName.substring(0, lastDotIndex);
                    const step = Math.floor(particles.length / files.length);
                    const idx = (i * step + Math.floor(Math.random()*step)) % particles.length;
                    particles[idx].isPhoto = true; 
                    particles[idx].photoData = { img: img }; 
                    particles[idx].label = fileName;
                    if (i === files.length - 1) recalculatePhotos();
                }
            }; reader.readAsDataURL(file);
        });
    });

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 2, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);
    const camera = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 1280, height: 720 });
    camera.start();
    renderLoop();

</script>
</body>
</html>