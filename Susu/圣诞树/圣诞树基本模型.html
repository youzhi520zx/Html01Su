<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Golden Christmas - Ultimate Edition</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Great+Vibes&family=Cinzel:wght@700&display=swap" rel="stylesheet">

    <style>
        body {
            margin: 0; overflow: hidden; background-color: #000;
            font-family: 'Cinzel', serif; user-select: none;
        }
        #canvas-container { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; }
        
        /* Ê†áÈ¢òÊ†∑Âºè */
        #title-layer {
            position: absolute; top: 8%; left: 0; width: 100%; text-align: center; z-index: 10; pointer-events: none;
        }
        h1 {
            margin: 0; font-family: 'Great Vibes', cursive; font-size: 6.5rem;
            background: linear-gradient(to bottom, #FFFFFF, #FFD700, #DAA520);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 30px rgba(255, 215, 0, 0.5));
            opacity: 0; animation: fadeIn 3s ease-out forwards 0.5s;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(-30px); } to { opacity: 1; transform: translateY(0); } }

        /* ÊëÑÂÉèÂ§¥È¢ÑËßà */
        #cam-preview {
            position: absolute; bottom: 20px; right: 20px; width: 180px; height: 135px; z-index: 20;
            border: 2px solid #FFD700; border-radius: 8px; overflow: hidden; background: #000;
            box-shadow: 0 0 25px rgba(255, 215, 0, 0.2); opacity: 0; transition: opacity 1s;
        }
        #webcam { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }

        /* UI Èù¢Êùø */
        #ui-panel {
            position: absolute; bottom: 40px; left: 40px; z-index: 20;
            color: #D4AF37; background: rgba(5, 5, 5, 0.9); padding: 25px;
            border-left: 4px solid #FFD700; backdrop-filter: blur(15px);
            width: 300px; border-radius: 0 12px 12px 0;
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            max-height: 80vh; overflow-y: auto;
        }
        
        /* ÈöêËóèÊªöÂä®Êù°‰ΩÜ‰øùÁïôÂäüËÉΩ */
        #ui-panel::-webkit-scrollbar { width: 6px; }
        #ui-panel::-webkit-scrollbar-thumb { background: #333; border-radius: 3px; }

        .status-row { margin-bottom: 15px; font-size: 0.95rem; display: flex; align-items: center; justify-content: space-between; }
        .icon { width: 30px; text-align: center; font-size: 1.4rem; margin-right: 10px; }
        .highlight { color: #FFF; font-weight: bold; text-shadow: 0 0 12px #FFD700; }
        .sub-text { font-size: 0.75rem; color: #999; margin-left: 45px; display: block; line-height: 1.4; margin-bottom: 8px;}

        /* ‰∏ä‰º†ÊåâÈíÆÊ†∑Âºè */
        .upload-group { margin-top: 15px; padding-top: 15px; border-top: 1px solid #333; }
        .upload-item { display: flex; align-items: center; margin-bottom: 10px; }
        .upload-btn {
            background: transparent; border: 1px solid #555; color: #888;
            padding: 5px 10px; border-radius: 4px; cursor: pointer;
            font-family: 'Cinzel', serif; font-size: 0.7rem; flex-grow: 1;
            transition: 0.3s; text-align: left;
        }
        .upload-btn:hover { border-color: #FFD700; color: #FFD700; }
        .upload-btn.active { border-color: #FFD700; background: rgba(255, 215, 0, 0.1); color: #FFF; }
        input[type="file"] { display: none; }

        /* ÂÖ®Â±èÊåâÈíÆ */
        #fullscreen-btn {
            position: absolute; top: 30px; right: 30px; z-index: 30;
            background: transparent; border: 1px solid #FFD700; color: #FFD700;
            padding: 10px 25px; cursor: pointer; font-family: 'Cinzel', serif;
            text-transform: uppercase; letter-spacing: 2px; transition: 0.3s; font-size: 0.8rem;
        }
        #fullscreen-btn:hover { background: #FFD700; color: #000; box-shadow: 0 0 20px #FFD700; }

        /* Loading */
        #loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: #FFD700; transition: opacity 0.8s;
        }
        .spinner {
            width: 60px; height: 60px; border: 4px solid #333; border-top: 4px solid #FFD700;
            border-radius: 50%; animation: spin 1s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>
</head>
<body>

    <div id="loading">
        <div class="spinner"></div>
        <div style="font-size: 1.8rem; letter-spacing: 6px;">WINTER MAGIC</div>
        <div style="font-size: 0.8rem; opacity: 0.6; margin-top: 10px;">Decorating Tree...</div>
    </div>

    <div id="title-layer">
        <h1>Merry Christmas!</h1>
    </div>

    <div id="cam-preview">
        <video id="webcam" autoplay playsinline></video>
    </div>

    <button id="fullscreen-btn">Fullscreen</button>

    <div id="ui-panel">
        <div class="status-row">Gesture: <span id="gesture-text" class="highlight">Initializing...</span></div>
        <div style="border-top: 1px solid #444; margin: 15px 0;"></div>
        
        <div class="status-row"><div><span class="icon">üñê</span> <span>Open Hand</span></div></div>
        <span class="sub-text">Scatter Particles</span>
        <div class="status-row"><div><span class="icon">‚úä</span> <span>Closed Fist</span></div></div>
        <span class="sub-text">Assemble Tree</span>

        <div class="upload-group">
            <div style="font-size: 0.9rem; color:#FFF; margin-bottom: 15px;">‚ú® Magic Photos</div>
            
            <div class="upload-item">
                <span class="icon">‚úåÔ∏è</span>
                <input type="file" id="file-victory" accept="image/*">
                <button class="upload-btn" onclick="document.getElementById('file-victory').click()" id="btn-victory">Upload for "Victory"</button>
            </div>

            <div class="upload-item">
                <span class="icon">üëç</span>
                <input type="file" id="file-thumb" accept="image/*">
                <button class="upload-btn" onclick="document.getElementById('file-thumb').click()" id="btn-thumb">Upload for "Like"</button>
            </div>

            <div class="upload-item">
                <span class="icon">ü§ü</span>
                <input type="file" id="file-love" accept="image/*">
                <button class="upload-btn" onclick="document.getElementById('file-love').click()" id="btn-love">Upload for "Love"</button>
            </div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';
        import { FilesetResolver, GestureRecognizer } from '@mediapipe/tasks-vision';

        // --- 1. ÂÆåÊï¥Âú£ËØûÊ†ëÈÖçÁΩÆ (‰øùÁïôÂéüÊúâÁöÑÂ§çÊùÇÈÖçÁΩÆ) ---
        const TOTAL_PARTICLES = 6500;
        const RATIOS = { lights: 0.001, balls: 0.035, gifts: 0.04, canes: 0.03, socks: 0.02, hats: 0.03 };
        const CONFIG = {
            counts: {
                lights: Math.ceil(TOTAL_PARTICLES * RATIOS.lights),
                balls: Math.floor(TOTAL_PARTICLES * RATIOS.balls),
                gifts: Math.floor(TOTAL_PARTICLES * RATIOS.gifts),
                canes: Math.floor(TOTAL_PARTICLES * RATIOS.canes),
                socks: Math.floor(TOTAL_PARTICLES * RATIOS.socks),
                hats: Math.floor(TOTAL_PARTICLES * RATIOS.hats),
                needles: Math.floor(TOTAL_PARTICLES * 0.844),
                snow: 2500 
            },
            physics: { needle: 0.15, gift: 0.02, ball: 0.05, light: 0.09, common: 0.04 },
            colors: { needle: 0x004225, gold: 0xFFD700, red: 0x8B0000, palette: [0xFFD700, 0xCC0000, 0x0022AA, 0xC0C0C0, 0x800080] },
            tree: { height: 26, radius: 11 }
        };

        let viewState = 'TREE_SHAPE'; 
        let handData = { x: 0.5, y: 0.5, isActive: false };
        
        // ÂõæÁâáÂ±ïÁ§∫Áõ∏ÂÖ≥
        const gestureImages = { 'Victory': null, 'Thumb_Up': null, 'ILoveYou': null };
        let activeImageTexture = null;

        // --- 2. Âú∫ÊôØ‰∏éÁõ∏Êú∫ ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000000); 

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 6, 65);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        container.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.dampingFactor = 0.05; controls.enablePan = false; controls.maxDistance = 150;

        const headLight = new THREE.SpotLight(0xFFF8E7, 1800);
        headLight.angle = 0.6; headLight.penumbra = 0.5; headLight.decay = 1.5; headLight.distance = 200;
        headLight.castShadow = true;
        camera.add(headLight); scene.add(camera);
        const rimLight = new THREE.PointLight(0x445588, 250);
        rimLight.position.set(0, 20, -40); scene.add(rimLight);

        // --- 3. È≠îÊ≥ïÁõ∏Ê°Ü (Hologram Frame) ---
        const frameGroup = new THREE.Group();
        camera.add(frameGroup); 
        frameGroup.position.set(0, 0, -15); 
        frameGroup.visible = false;

        const photoGeo = new THREE.PlaneGeometry(8, 8); 
        const photoMat = new THREE.MeshBasicMaterial({ transparent: true, opacity: 0, side: THREE.DoubleSide, depthTest: false });
        const photoMesh = new THREE.Mesh(photoGeo, photoMat);
        frameGroup.add(photoMesh);

        const borderGeo = new THREE.RingGeometry(4, 4.2, 4); 
        const borderMat = new THREE.MeshBasicMaterial({ color: 0xFFD700, side: THREE.DoubleSide, transparent:true, opacity:0, depthTest: false });
        const borderMesh = new THREE.Mesh(borderGeo, borderMat);
        borderMesh.rotation.z = Math.PI / 4; 
        frameGroup.add(borderMesh);

        // --- 4. ËµÑÊ∫êÁîüÊàê (Á∫πÁêÜ‰∏éÂá†‰Ωï‰Ωì - ÊÅ¢Â§çÂÆåÊï¥Áâà) ---
        function createGiftTexture(baseColor) {
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = baseColor; ctx.fillRect(0,0,128,128);
            ctx.fillStyle = '#FFD700'; ctx.shadowColor = 'rgba(0,0,0,0.5)'; ctx.shadowBlur = 6;
            ctx.fillRect(48, 0, 32, 128); ctx.fillRect(0, 48, 128, 32);
            return new THREE.CanvasTexture(canvas);
        }
        function createCandyTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#FFFFFF'; ctx.fillRect(0,0,64,64);
            ctx.fillStyle = '#CC0000';
            for(let i=-64; i<128; i+=16) {
                ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i+12, 0); ctx.lineTo(i-4, 64); ctx.lineTo(i-16, 64); ctx.fill();
            }
            const tex = new THREE.CanvasTexture(canvas); tex.wrapS = THREE.RepeatWrapping; tex.wrapT = THREE.RepeatWrapping;
            return tex;
        }
        function createCandyGeo() {
            const path = new THREE.CatmullRomCurve3([
                new THREE.Vector3(0, -0.5, 0), new THREE.Vector3(0, 0.2, 0),
                new THREE.Vector3(0.15, 0.5, 0), new THREE.Vector3(0.35, 0.35, 0), new THREE.Vector3(0.35, 0.2, 0)
            ]);
            return new THREE.TubeGeometry(path, 12, 0.07, 8, false);
        }
        function createSockGeo() {
            const shape = new THREE.Shape();
            shape.moveTo(0,0); shape.lineTo(0.3,0); shape.lineTo(0.3,-0.6);
            shape.quadraticCurveTo(0.3,-0.9, 0.1,-0.9); shape.lineTo(-0.1,-0.9);
            shape.quadraticCurveTo(-0.3,-0.9,-0.3,-0.7); shape.quadraticCurveTo(-0.3,-0.5,-0.1,-0.5); shape.lineTo(0,-0.4);
            return new THREE.ExtrudeGeometry(shape, { depth: 0.1, bevelEnabled:true, bevelThickness:0.03, bevelSegments:2 });
        }
        function createHatGeo() {
            const coneGeo = new THREE.ConeGeometry(0.3, 0.7, 16); coneGeo.translate(0, 0.35, 0);
            const coneColors = new Float32Array(coneGeo.attributes.position.count * 3);
            for(let i=0; i<coneColors.length; i+=3) { coneColors[i]=0.8; coneColors[i+1]=0; coneColors[i+2]=0; }
            coneGeo.setAttribute('color', new THREE.BufferAttribute(coneColors, 3));
            const rimGeo = new THREE.TorusGeometry(0.3, 0.1, 8, 16); rimGeo.rotateX(Math.PI/2);
            const rimColors = new Float32Array(rimGeo.attributes.position.count * 3);
            for(let i=0; i<rimColors.length; i++) rimColors[i]=1;
            rimGeo.setAttribute('color', new THREE.BufferAttribute(rimColors, 3));
            const ballGeo = new THREE.SphereGeometry(0.1, 8, 8); ballGeo.translate(0, 0.7, 0);
            const ballColors = new Float32Array(ballGeo.attributes.position.count * 3);
            for(let i=0; i<ballColors.length; i++) ballColors[i]=1;
            ballGeo.setAttribute('color', new THREE.BufferAttribute(ballColors, 3));
            return BufferGeometryUtils.mergeGeometries([coneGeo, rimGeo, ballGeo]);
        }

        // --- 5. ÂÆåÊï¥Á≤íÂ≠êÁ≥ªÁªüÊûÑÂª∫ ---
        const particles = [];
        const dummy = new THREE.Object3D();
        const colorHelper = new THREE.Color();
        const getScatterPos = (radius) => {
            const r = radius * Math.cbrt(Math.random());
            const theta = Math.random() * 2 * Math.PI;
            const phi = Math.acos(2 * Math.random() - 1);
            return new THREE.Vector3(r * Math.sin(phi) * Math.cos(theta), r * Math.sin(phi) * Math.sin(theta), r * Math.cos(phi));
        };

        function createParticles() {
            // Á§ºÁâ©„ÄÅÁêÉ‰Ωì„ÄÅÊãêÊùñÁ≠âÂÆåÊï¥ÂÆû‰æãÂåñÁΩëÊ†º
            const needleGeo = new THREE.CylinderGeometry(0.02, 0.1, 0.9, 4);
            const needleMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.needle, roughness: 0.3, metalness: 0.2 });
            const needleMesh = new THREE.InstancedMesh(needleGeo, needleMat, CONFIG.counts.needles);
            scene.add(needleMesh);

            const giftGeo = new THREE.BoxGeometry(1.2, 1.2, 1.2);
            const giftMat = new THREE.MeshStandardMaterial({ map: createGiftTexture('#EEEEEE'), color: 0xffffff, roughness: 0.1, metalness: 0.5 });
            const giftMesh = new THREE.InstancedMesh(giftGeo, giftMat, CONFIG.counts.gifts);
            scene.add(giftMesh);

            const ballGeo = new THREE.SphereGeometry(0.5, 24, 24);
            const ballMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.05, metalness: 0.9 });
            const ballMesh = new THREE.InstancedMesh(ballGeo, ballMat, CONFIG.counts.balls);
            scene.add(ballMesh);

            const caneGeo = createCandyGeo();
            const caneMat = new THREE.MeshStandardMaterial({ map: createCandyTexture(), roughness: 0.4, metalness: 0.1 });
            const caneMesh = new THREE.InstancedMesh(caneGeo, caneMat, CONFIG.counts.canes);
            scene.add(caneMesh);

            const sockGeo = createSockGeo();
            const sockMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.7, metalness: 0.1 });
            const sockMesh = new THREE.InstancedMesh(sockGeo, sockMat, CONFIG.counts.socks);
            scene.add(sockMesh);

            const hatGeo = createHatGeo();
            const hatMat = new THREE.MeshStandardMaterial({ vertexColors: true, roughness: 0.8, metalness: 0.1 });
            const hatMesh = new THREE.InstancedMesh(hatGeo, hatMat, CONFIG.counts.hats);
            scene.add(hatMesh);

            const lightGeo = new THREE.SphereGeometry(0.15, 8, 8);
            const lightMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0xffffff, emissiveIntensity: 8.0 });
            const lightMesh = new THREE.InstancedMesh(lightGeo, lightMat, CONFIG.counts.lights);
            scene.add(lightMesh);

            // ÁîüÊàêÈÄªËæë
            const generate = (mesh, count, type, weight, hasColor) => {
                for (let i = 0; i < count; i++) {
                    if (hasColor) {
                        const hex = CONFIG.colors.palette[Math.floor(Math.random() * CONFIG.colors.palette.length)];
                        colorHelper.setHex(hex); mesh.setColorAt(i, colorHelper);
                    }
                    const yNorm = i / count;
                    const rBase = CONFIG.tree.radius * (1 - yNorm);
                    let r = rBase + (Math.random()-0.5)*1.5;
                    let y = (yNorm * CONFIG.tree.height) - (CONFIG.tree.height/2);
                    const theta = i * 2.4 + Math.random();

                    let scale = 1;
                    if (type === 'gift') {
                        r = Math.random() * 9; y = -CONFIG.tree.height/2 + 1.5 + Math.random() * 3;
                        scale = 0.8 + Math.random() * 0.5;
                    } else if (type === 'light') r = rBase * 1.1;

                    const treePos = new THREE.Vector3(r*Math.cos(theta), y, r*Math.sin(theta));
                    let scatterPos = (type === 'needle') ? getScatterPos(500) : getScatterPos(50);

                    dummy.position.copy(scatterPos); dummy.updateMatrix(); mesh.setMatrixAt(i, dummy.matrix);

                    particles.push({
                        mesh, index: i, type, weight: weight * (0.8 + Math.random() * 0.4),
                        treePos, scatterPos, currentPos: scatterPos.clone(), baseScale: scale,
                        rotation: new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, 0),
                        blinkPhase: Math.random()*Math.PI*2, blinkSpeed: 3 + Math.random()*3
                    });
                }
            };

            generate(needleMesh, CONFIG.counts.needles, 'needle', CONFIG.physics.needle, false);
            generate(giftMesh, CONFIG.counts.gifts, 'gift', CONFIG.physics.gift, true);
            generate(ballMesh, CONFIG.counts.balls, 'ball', CONFIG.physics.ball, true);
            generate(caneMesh, CONFIG.counts.canes, 'cane', CONFIG.physics.common, false);
            generate(sockMesh, CONFIG.counts.socks, 'sock', CONFIG.physics.common, true);
            generate(hatMesh, CONFIG.counts.hats, 'hat', CONFIG.physics.common, false);
            generate(lightMesh, CONFIG.counts.lights, 'light', CONFIG.physics.light, true);
        }
        createParticles();

        // ËæÖÂä©ÂÖÉÁ¥†ÔºöÊòüÊòü‰∏é‰∏ùÂ∏¶
        const starShape = new THREE.Shape();
        for(let i=0; i<10; i++){
            const l = i%2==1 ? 0.6 : 1.5; const a = i/5 * Math.PI;
            starShape.lineTo(Math.cos(a)*l, Math.sin(a)*l);
        }
        const starGeo = new THREE.ExtrudeGeometry(starShape, {depth:0.4, bevelEnabled:true, bevelThickness:0.1, bevelSize:0.1, bevelSegments:2});
        const starMat = new THREE.MeshStandardMaterial({color: CONFIG.colors.gold, emissive: CONFIG.colors.gold, emissiveIntensity: 2.0, roughness:0.1, metalness:1.0});
        const starMesh = new THREE.Mesh(starGeo, starMat);
        starMesh.position.set(0, CONFIG.tree.height/2 + 1.5, 0); scene.add(starMesh);

        const ribbonPoints = []; const ribbonH = CONFIG.tree.height + 4;
        for(let i=0; i<150; i++) {
            const t = i/150; const angle = t * Math.PI * 12; const r = (1-t) * 13 + 1; const y = t * ribbonH - ribbonH/2 - 2;
            ribbonPoints.push(new THREE.Vector3(Math.cos(angle)*r, y, Math.sin(angle)*r));
        }
        const ribbonGeo = new THREE.TubeGeometry(new THREE.CatmullRomCurve3(ribbonPoints), 100, 0.1, 8, false);
        const ribbonMat = new THREE.MeshStandardMaterial({ color: CONFIG.colors.gold, emissive: CONFIG.colors.gold, emissiveIntensity: 3, transparent: true, opacity: 0.6 });
        const ribbonMesh = new THREE.Mesh(ribbonGeo, ribbonMat); scene.add(ribbonMesh);

        // --- 6. ÁßØÈõ™Á≥ªÁªü (‰øùÊåÅËá™ÁÑ∂È£òÂä®) ---
        const snowGeo = new THREE.BufferGeometry();
        const snowPos = new Float32Array(CONFIG.counts.snow * 3);
        const snowVel = new Float32Array(CONFIG.counts.snow);
        const snowData = []; 
        const groundBaseY = -CONFIG.tree.height/2 - 1; 

        for(let i=0; i<CONFIG.counts.snow; i++) {
            const x = (Math.random()-0.5)*120;
            const z = (Math.random()-0.5)*120;
            const y = Math.random() * 80;
            snowPos[i*3] = x; snowPos[i*3+1] = y; snowPos[i*3+2] = z;
            snowVel[i] = 0.05 + Math.random() * 0.1;
            const dist = Math.sqrt(x*x + z*z);
            const pileHeight = 4.5 * Math.exp(-(dist*dist)/60); 
            snowData.push({ state: 0, groundY: groundBaseY + Math.max(0, pileHeight) + (Math.random()*0.5) });
        }
        snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
        const snowMat = new THREE.PointsMaterial({color:0xffffff, size:0.4, transparent:true, opacity:0.8, blending:THREE.AdditiveBlending});
        const snowSystem = new THREE.Points(snowGeo, snowMat);
        scene.add(snowSystem);

        // --- 7. ÂõæÁâá‰∏ä‰º†Â§ÑÁêÜÈÄªËæë ---
        const textureLoader = new THREE.TextureLoader();
        function handleImageUpload(inputId, btnId, gestureKey) {
            document.getElementById(inputId).addEventListener('change', function(e) {
                if(e.target.files && e.target.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(evt) {
                        const img = new Image();
                        img.src = evt.target.result;
                        img.onload = () => {
                            const tex = textureLoader.load(img.src);
                            tex.colorSpace = THREE.SRGBColorSpace;
                            gestureImages[gestureKey] = { texture: tex, ratio: img.width / img.height };
                            const btn = document.getElementById(btnId);
                            btn.innerText = "Saved!"; btn.classList.add('active');
                        };
                    };
                    reader.readAsDataURL(e.target.files[0]);
                }
            });
        }
        handleImageUpload('file-victory', 'btn-victory', 'Victory');
        handleImageUpload('file-thumb', 'btn-thumb', 'Thumb_Up');
        handleImageUpload('file-love', 'btn-love', 'ILoveYou');

        // --- 8. AI & Âä®ÁîªÂæ™ÁéØ ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0.75; bloomPass.strength = 1.6; bloomPass.radius = 0.5;
        composer.addPass(bloomPass);

        const gestureText = document.getElementById('gesture-text');
        const video = document.getElementById('webcam');
        let currentOpacity = 0;
        let targetOpacity = 0;

        async function initAI() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            const gestureRecognizer = await GestureRecognizer.createFromOptions(vision, {
                baseOptions: { modelAssetPath: "https://storage.googleapis.com/mediapipe-models/gesture_recognizer/gesture_recognizer/float16/1/gesture_recognizer.task", delegate: "GPU" },
                runningMode: "VIDEO"
            });
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                video.srcObject = stream;
                video.addEventListener('loadeddata', () => {
                    document.getElementById('loading').style.opacity = 0;
                    document.getElementById('cam-preview').style.opacity = 1;
                    setTimeout(() => document.getElementById('loading').remove(), 800);
                    predictLoop(gestureRecognizer);
                });
            }
        }

        let lastVideoTime = -1;
        function predictLoop(recognizer) {
            if (video.currentTime !== lastVideoTime) {
                const results = recognizer.recognizeForVideo(video, Date.now());
                if (results.gestures.length > 0) {
                    const name = results.gestures[0][0].categoryName;
                    gestureText.innerText = name; gestureText.style.color = "#FFD700";

                    // Ê†ëÁöÑÊéßÂà∂
                    if (name === 'Open_Palm') viewState = 'SCATTERED';
                    else if (name === 'Closed_Fist') viewState = 'TREE_SHAPE';

                    // ËßÜËßíÊéßÂà∂
                    if (name === 'Open_Palm' || name === 'Closed_Fist') {
                        const lm = results.landmarks[0];
                        if (lm && lm[9]) { handData.isActive = true; handData.x = 1 - lm[9].x; handData.y = lm[9].y; }
                    } else handData.isActive = false;

                    // ÂõæÁâáÂ±ïÁ§∫ÊéßÂà∂
                    if (gestureImages[name]) {
                        if (activeImageTexture !== gestureImages[name].texture) {
                            activeImageTexture = gestureImages[name].texture;
                            photoMesh.material.map = activeImageTexture;
                            photoMesh.material.needsUpdate = true;
                            const ratio = gestureImages[name].ratio || 1;
                            photoMesh.scale.set(1, 1/ratio, 1);
                        }
                        targetOpacity = 1;
                    } else {
                        targetOpacity = 0;
                    }
                } else {
                    gestureText.innerText = "..."; gestureText.style.color = "#666";
                    handData.isActive = false; targetOpacity = 0;
                }
                lastVideoTime = video.currentTime;
            }
            requestAnimationFrame(() => predictLoop(recognizer));
        }
        initAI();

        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen();
            else if (document.exitFullscreen) document.exitFullscreen();
        });

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            const isTree = viewState === 'TREE_SHAPE';

            controls.update();

            // ËßÜËßíË∑üÈöè
            if (handData.isActive) {
                const spherical = new THREE.Spherical().setFromVector3(camera.position);
                spherical.theta -= (handData.x - 0.5) * 0.05;
                spherical.phi = Math.max(0.1, Math.min(Math.PI / 2 - 0.1, spherical.phi + (handData.y - 0.5) * 0.02));
                camera.position.setFromSpherical(spherical);
                camera.lookAt(0, 6, 0);
            }

            // Á≤íÂ≠êÊõ¥Êñ∞ (ÂÆåÊï¥ÈÄªËæë)
            particles.forEach(p => {
                let target = isTree ? p.treePos : p.scatterPos;
                const floatScale = isTree ? 0 : 1;
                const fx = (p.type !== 'needle') ? Math.sin(time + p.index)*0.5*floatScale : 0;
                const fy = (p.type !== 'needle') ? Math.cos(time * 0.8 + p.index)*0.5*floatScale : 0;
                
                p.currentPos.x += (target.x + fx - p.currentPos.x) * p.weight;
                p.currentPos.y += (target.y + fy - p.currentPos.y) * p.weight;
                p.currentPos.z += (target.z - p.currentPos.z) * p.weight;
                
                dummy.position.copy(p.currentPos);
                if (isTree) {
                    if (p.type === 'needle') { dummy.lookAt(0, p.currentPos.y, 0); dummy.rotateX(-Math.PI/2); dummy.scale.setScalar(1); }
                    else if (p.type === 'gift') { dummy.rotation.set(0, p.index, 0); dummy.scale.setScalar(p.baseScale); }
                    else if (p.type === 'light') { dummy.rotation.copy(p.rotation); dummy.scale.setScalar(1 + 0.5 * Math.sin(time*p.blinkSpeed + p.blinkPhase)); }
                    else if (p.type === 'cane') { dummy.lookAt(0, p.currentPos.y, 0); dummy.rotateX(Math.PI/2); dummy.rotateZ(Math.PI); dummy.scale.setScalar(1); }
                    else if (p.type === 'hat') { dummy.rotation.set(0, p.index, 0); dummy.scale.setScalar(1); }
                    else { dummy.rotation.copy(p.rotation); dummy.scale.setScalar(1); }
                } else {
                    let s = (p.type === 'needle') ? 1 : 1.3; dummy.scale.setScalar(s);
                }
                dummy.updateMatrix(); p.mesh.setMatrixAt(p.index, dummy.matrix);
            });
            scene.traverse(o => { if(o.isInstancedMesh) o.instanceMatrix.needsUpdate = true; });

            // Ë£ÖÈ•∞Êõ¥Êñ∞
            starMesh.rotation.y = time * 0.8; ribbonMesh.rotation.y = -time * 0.2;
            const sScale = isTree ? 1 : 0.01;
            starMesh.scale.lerp(new THREE.Vector3(sScale, sScale, sScale), 0.05);
            ribbonMesh.scale.lerp(new THREE.Vector3(sScale, sScale, sScale), 0.05);

            // ÁßØÈõ™Êõ¥Êñ∞
            const snPos = snowSystem.geometry.attributes.position.array;
            for(let i=0; i<CONFIG.counts.snow; i++) {
                const d = snowData[i];
                if (d.state === 1) { 
                    if (!isTree) { snPos[i*3+1] -= 0.3; if (snPos[i*3+1] < -30) { d.state = 0; snPos[i*3+1] = 60 + Math.random()*20; } }
                    else { snPos[i*3+1] = d.groundY; if (Math.random() < 0.002) { d.state = 0; snPos[i*3+1] = 60 + Math.random()*20; } }
                } else {
                    snPos[i*3+1] -= snowVel[i];
                    snPos[i*3] += Math.sin(time * 0.5 + i) * 0.02; snPos[i*3+2] += Math.cos(time * 0.3 + i) * 0.02;
                    if (isTree && snPos[i*3+1] <= d.groundY) { d.state = 1; snPos[i*3+1] = d.groundY; } 
                    else if (snPos[i*3+1] < -30) {
                        snPos[i*3+1] = 60 + Math.random()*20; snPos[i*3] = (Math.random()-0.5)*120; snPos[i*3+2] = (Math.random()-0.5)*120; 
                        const dist = Math.sqrt(snPos[i*3]*snPos[i*3] + snPos[i*3+2]*snPos[i*3+2]);
                        const pileHeight = 4.5 * Math.exp(-(dist*dist)/60);
                        d.groundY = groundBaseY + Math.max(0, pileHeight) + (Math.random()*0.5);
                    }
                }
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;

            // Áõ∏Ê°ÜÂä®Áîª
            currentOpacity += (targetOpacity - currentOpacity) * 0.1;
            if (currentOpacity > 0.01) {
                photoMesh.material.opacity = currentOpacity;
                borderMesh.material.opacity = currentOpacity;
                frameGroup.visible = true;
                const scale = 1 + Math.sin(time * 2) * 0.02;
                borderMesh.scale.set(scale, scale, 1);
            } else {
                frameGroup.visible = false;
            }

            composer.render();
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>