<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js ç‰©ç†è·Ÿéšç²’å­ç³»ç»Ÿ</title>
    <style>
        :root {
            --primary: #00f2ff;
            --panel-bg: rgba(10, 10, 12, 0.8);
            --border: rgba(255, 255, 255, 0.15);
        }

        body {
            margin: 0; overflow: hidden; background: #000;
            font-family: 'Segoe UI', sans-serif; color: white;
            user-select: none;
        }

        #video-input { display: none; transform: scaleX(-1); }

        /* èƒŒæ™¯ï¼šæ·±ç©º */
        #canvas-container {
            position: absolute; inset: 0; z-index: 1;
            background: radial-gradient(circle at center, #1a1a24 0%, #000 100%);
        }

        /* æ§åˆ¶é¢æ¿ */
        #ui-panel {
            position: absolute; top: 20px; right: 20px; width: 260px;
            background: var(--panel-bg);
            backdrop-filter: blur(25px); -webkit-backdrop-filter: blur(25px);
            border: 1px solid var(--border);
            border-radius: 12px; padding: 20px; z-index: 10;
            box-shadow: 0 15px 40px rgba(0,0,0,0.6);
            transition: transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        h2 {
            margin: 0 0 15px 0; font-size: 14px; text-transform: uppercase;
            letter-spacing: 2px; color: var(--primary); text-align: center;
            border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px;
        }

        .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 15px; }

        button {
            background: rgba(255,255,255,0.08); border: 1px solid transparent;
            color: #ccc; padding: 10px 0; border-radius: 6px; cursor: pointer;
            font-size: 12px; transition: 0.2s;
        }
        button:hover { background: rgba(255,255,255,0.2); color: white; }
        button.active {
            background: var(--primary); color: #000; font-weight: bold;
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.3);
        }

        .control-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 15px; font-size: 12px; color: #aaa; }
        input[type="color"] { width: 60px; height: 25px; border: none; background: none; cursor: pointer; }

        #status {
            padding: 12px; background: rgba(0,0,0,0.4); border-radius: 8px;
            font-size: 12px; text-align: center; border-left: 3px solid #555;
            transition: 0.3s;
        }

        /* åŠ è½½ */
        #loader {
            position: fixed; inset: 0; background: #000; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .pulse {
            width: 60px; height: 60px; background: var(--primary);
            border-radius: 50%; animation: pulse-anim 1.5s infinite;
        }
        @keyframes pulse-anim { 0% { transform: scale(0.8); opacity: 0.5; } 100% { transform: scale(1.5); opacity: 0; } }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

<div id="loader">
    <div class="pulse"></div>
    <p style="color:#666; margin-top:20px; font-size:12px;">æ­£åœ¨åˆå§‹åŒ–ç‰©ç†å¼•æ“...</p>
</div>

<div id="ui-panel">
    <h2>æµä½“è·Ÿéšç³»ç»Ÿ</h2>
    <div class="btn-grid">
        <button onclick="setMode('sphere')" class="active" id="btn-sphere">ğŸ”® çµçƒ</button>
        <button onclick="setMode('heart')" id="btn-heart">â¤ï¸ è„‰åŠ¨</button>
        <button onclick="setMode('shield')" id="btn-shield">ğŸ›¡ï¸ åŠ›åœº</button>
        <button onclick="setMode('dna')" id="btn-dna">ğŸ§¬ åŸºå› </button>
        <button onclick="setMode('cube')" id="btn-cube">ğŸ§Š æ™¶ä½“</button>
        <button onclick="setMode('cloud')" id="btn-cloud">â˜ï¸ æ˜Ÿäº‘</button>
    </div>

    <div class="control-row">
        <span>ç²’å­è‰²è°ƒ</span>
        <input type="color" id="colorPicker" value="#00f2ff">
    </div>

    <div id="status">ç­‰å¾…æ‰‹åŠ¿...</div>
</div>

<video id="video-input"></video>
<div id="canvas-container"></div>

<script>
    // --- 1. Three.js åœºæ™¯ ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050505, 0.0015);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 55;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // --- 2. ç²’å­æ•°æ®ç»“æ„ ---
    const COUNT = 16000;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(COUNT * 3);
    
    // å­˜å‚¨ä¸åŒå½¢æ€çš„æ•°æ®
    const shapes = { sphere:[], heart:[], shield:[], dna:[], cube:[], cloud:[] };
    // å­˜å‚¨å…¨å±æ‰©æ•£æ€çš„æ•°æ®
    const homePositions = new Float32Array(COUNT * 3);
    
    // åˆå§‹åŒ–æ•°æ®
    function initData() {
        const vec = new THREE.Vector3();
        
        for(let i=0; i<COUNT; i++) {
            // 1. å…¨å±æ€ (Home) - åƒç©ºæ°”ä¸€æ ·å¼¥æ¼«
            homePositions[i*3] = (Math.random()-0.5) * 200;
            homePositions[i*3+1] = (Math.random()-0.5) * 120;
            homePositions[i*3+2] = (Math.random()-0.5) * 100;
            
            // åˆå§‹ä½ç½®
            positions[i*3] = homePositions[i*3];
            positions[i*3+1] = homePositions[i*3+1];
            positions[i*3+2] = homePositions[i*3+2];

            // 2. å½¢çŠ¶æ€ (Offsets)
            // Sphere
            getPointOnSphere(12, vec);
            shapes.sphere.push(vec.x, vec.y, vec.z);

            // Heart
            let t = Math.random() * Math.PI * 2;
            let hx = 16 * Math.pow(Math.sin(t), 3);
            let hy = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            let hz = (Math.random()-0.5) * 4;
            let s = Math.random(); // å¡«å……
            shapes.heart.push(hx*s, (hy*s)+2, hz*s);

            // Shield (åŠåœ†æŠ¤ç›¾)
            getPointOnSphere(14, vec);
            if(vec.z < 0) vec.z *= 0.1; // å‹æ‰èƒŒé¢
            shapes.shield.push(vec.x, vec.y, vec.z);

            // DNA
            let dh = (Math.random()-0.5)*40;
            let ang = dh * 0.5;
            let off = (i%2===0)?0:Math.PI;
            shapes.dna.push(Math.cos(ang+off)*6, dh, Math.sin(ang+off)*6);

            // Cube
            let edge = 18;
            shapes.cube.push((Math.random()-0.5)*edge, (Math.random()-0.5)*edge, (Math.random()-0.5)*edge);

            // Cloud (æ‰å¹³æ˜Ÿäº‘)
            let cr = Math.random()*20;
            let ca = Math.random()*Math.PI*2;
            shapes.cloud.push(Math.cos(ca)*cr, (Math.random()-0.5)*4, Math.sin(ca)*cr);
        }
    }

    function getPointOnSphere(r, target) {
        const u = Math.random(), v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);
        target.x = r * Math.sin(phi) * Math.cos(theta);
        target.y = r * Math.sin(phi) * Math.sin(theta);
        target.z = r * Math.cos(phi);
    }

    initData();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    // æè´¨
    const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');
    const material = new THREE.PointsMaterial({
        size: 0.5,
        color: 0x00f2ff,
        map: sprite,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- 3. äº¤äº’é€»è¾‘ ---
    let currentShape = shapes.sphere;
    let handPos = new THREE.Vector3(0,0,0);
    // ç”¨äºç‰©ç†å¹³æ»‘çš„å‘é‡
    let smoothHandPos = new THREE.Vector3(0,0,0); 
    // handPower: 0 = æ•£å¼€, 1 = èšæ‹¢
    let handPower = 0; 
    let hasHand = false;

    window.setMode = (mode) => {
        currentShape = shapes[mode];
        document.querySelectorAll('.btn-grid button').forEach(b => b.classList.remove('active'));
        document.getElementById('btn-'+mode).classList.add('active');
    };
    document.getElementById('colorPicker').addEventListener('input', e => material.color.set(e.target.value));

    // --- 4. è§†è§‰å¤„ç† ---
    const statusDiv = document.getElementById('status');

    function onResults(results) {
        document.getElementById('loader').style.display = 'none';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            hasHand = true;
            const lm = results.multiHandLandmarks[0];

            // 1. åæ ‡æ˜ å°„ (æ‰‹å¿ƒä½ç½®)
            // å°† 0-1 æ˜ å°„åˆ° 3D ä¸–ç•Œåæ ‡ (-x ~ +x)
            // è§†å·®ä¿®æ­£ï¼šæ ¹æ®ç›¸æœº Z=55ï¼Œå¤§è‡´è§†é‡å®½ 100ï¼Œé«˜ 60
            const x = (0.5 - lm[9].x) * 100;
            const y = (0.5 - lm[9].y) * 60;
            handPos.set(x, y, 0);

            // 2. è®¡ç®—å¼ åˆ (æ‹‡æŒ‡4 - é£ŸæŒ‡8)
            const d = Math.sqrt(
                Math.pow(lm[4].x - lm[8].x, 2) + Math.pow(lm[4].y - lm[8].y, 2)
            );

            // æ˜ å°„ï¼š<0.05 æåˆ(1), >0.15 å¼ å¼€(0)
            let targetPower = (0.15 - d) * 10;
            targetPower = Math.max(0, Math.min(1, targetPower));
            
            // å¹³æ»‘æ’å€¼
            handPower += (targetPower - handPower) * 0.15;

            // UI
            if(handPower > 0.6) {
                statusDiv.innerText = "âœŠ å®ä½“åŒ– (Drag)";
                statusDiv.style.borderLeftColor = "#00ff88";
                statusDiv.style.color = "#00ff88";
            } else {
                statusDiv.innerText = "ğŸ– æ°”æ€åŒ– (Flow)";
                statusDiv.style.borderLeftColor = "#00f2ff";
                statusDiv.style.color = "#fff";
            }
        } else {
            hasHand = false;
            // æ— æ‰‹æ—¶ï¼Œpower å½’é›¶ï¼Œæ‰‹ä½ç½®å½’ä¸­
            handPower += (0 - handPower) * 0.05;
            handPos.set(0, 0, 0);
            statusDiv.innerText = "å¯»æ‰¾æ‰‹åŠ¿...";
            statusDiv.style.borderLeftColor = "#555";
            statusDiv.style.color = "#888";
        }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6});
    hands.onResults(onResults);
    
    const cam = new Camera(document.getElementById('video-input'), {
        onFrame: async () => await hands.send({image: document.getElementById('video-input')}),
        width: 640, height: 480
    });
    cam.start();

    // --- 5. ç‰©ç†å¼•æ“ (æ ¸å¿ƒï¼šæƒ¯æ€§ä¸å˜åŠ¨) ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();

        // A. æ‰‹éƒ¨ä½ç½®å¹³æ»‘ (æƒ¯æ€§è·Ÿéš)
        // lerp å› å­è¶Šå°ï¼Œæ‹–å°¾æ„Ÿè¶Šå¼ºã€‚0.08 æ„Ÿè§‰åƒåœ¨æ°´é‡Œæ‹–åŠ¨ã€‚
        smoothHandPos.lerp(handPos, 0.08);

        // B. è§†å·®å€¾æ–œ (Parallax Tilt) - å–ä»£è‡ªè½¬
        // æ ¹æ®æ‰‹åœ¨å±å¹•çš„ä½ç½®ï¼Œå¾®è°ƒç²’å­ç³»ç»Ÿçš„è§’åº¦
        // æ‰‹åœ¨å·¦è¾¹ï¼Œç‰©ä½“ç¨å‘å·¦å€¾æ–œ
        const tiltX = smoothHandPos.y * 0.005; // ä¸Šä¸‹ç§»åŠ¨å¯¼è‡´ç»•Xè½´è½¬
        const tiltY = smoothHandPos.x * 0.005; // å·¦å³ç§»åŠ¨å¯¼è‡´ç»•Yè½´è½¬
        particles.rotation.x = -tiltX;
        particles.rotation.y = tiltY;

        // C. ç²’å­ä½ç½®æ›´æ–°
        const pArr = particles.geometry.attributes.position.array;

        for(let i=0; i<COUNT; i++) {
            const idx = i*3;

            // 1. åŸºç¡€å‘¼å¸å™ªéŸ³ (Variation)
            // å³ä½¿ä¸åŠ¨ï¼Œç²’å­ä¹Ÿåœ¨å¾®å¾®èµ·ä¼ï¼Œæ¨¡æ‹Ÿç”Ÿç‰©æ„Ÿ
            const noiseAmp = 0.5; // æŒ¯å¹…
            const noiseFreq = 0.5; // é¢‘ç‡
            const noiseX = Math.sin(time * noiseFreq + i) * noiseAmp;
            const noiseY = Math.cos(time * noiseFreq + i * 0.5) * noiseAmp;
            const noiseZ = Math.sin(time * noiseFreq + i * 0.2) * noiseAmp;

            // 2. ç›®æ ‡ä½ç½®è®¡ç®—
            // çŠ¶æ€ 0 (æ•£å¼€): åŸå§‹å…¨å±ä½ç½® + å‘¼å¸
            const homeX = homePositions[idx] + noiseX * 3; // æ•£å¼€æ—¶å‘¼å¸å¹…åº¦å¤§
            const homeY = homePositions[idx+1] + noiseY * 3;
            const homeZ = homePositions[idx+2] + noiseZ * 3;

            // çŠ¶æ€ 1 (èšæ‹¢): æ‰‹å¿ƒä½ç½® + å½¢çŠ¶åç§» + å‘¼å¸
            const shapeX = smoothHandPos.x + currentShape[idx] + noiseX;
            const shapeY = smoothHandPos.y + currentShape[idx+1] + noiseY;
            const shapeZ = smoothHandPos.z + currentShape[idx+2] + noiseZ;

            // 3. æ··åˆä½ç½®
            const targetX = homeX + (shapeX - homeX) * handPower;
            const targetY = homeY + (shapeY - homeY) * handPower;
            const targetZ = homeZ + (shapeZ - homeZ) * handPower;

            // 4. ç²’å­é£è¡Œ (Lerp)
            // æ¯ä¸ªç²’å­æœ‰ä¸åŒçš„é£è¡Œé€Ÿåº¦ï¼Œé€ æˆâ€œæ‹‰æ‰¯â€çš„æ•ˆæœ
            const speed = 0.1 + (i % 10) * 0.01; // 0.1 ~ 0.2 éšæœºé€Ÿåº¦
            
            pArr[idx]   += (targetX - pArr[idx])   * speed;
            pArr[idx+1] += (targetY - pArr[idx+1]) * speed;
            pArr[idx+2] += (targetZ - pArr[idx+2]) * speed;
        }

        particles.geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>