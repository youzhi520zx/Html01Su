<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gesture Heart Gallery</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Segoe UI', sans-serif; }
        canvas { display: block; }
        
        /* UI è¦†ç›–å±‚ */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            color: white;
            pointer-events: none; /* è®©ç‚¹å‡»ç©¿é€åˆ° Canvas */
        }
        
        /* æ–‡ä»¶ä¸Šä¼ æŒ‰é’® */
        .upload-btn {
            pointer-events: auto;
            background: rgba(255, 20, 100, 0.8);
            border: 1px solid #ff55aa;
            color: white;
            padding: 10px 20px;
            border-radius: 30px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            text-shadow: 0 0 5px rgba(255,255,255,0.5);
            display: inline-flex;
            align-items: center;
            gap: 8px;
        }
        .upload-btn:hover { background: #ff0055; box-shadow: 0 0 15px #ff0055; transform: scale(1.05); }
        
        /* çŠ¶æ€æç¤º */
        #status {
            margin-top: 10px;
            font-size: 12px;
            color: rgba(255,255,255,0.7);
            background: rgba(0,0,0,0.5);
            padding: 5px 10px;
            border-radius: 4px;
            display: inline-block;
        }

        /* éšè—çš„è§†é¢‘å…ƒç´ ç”¨äº AI */
        .input_video { display: none; }

        /* æ‚¬åœè¿›åº¦æ¡ */
        #cursor-ring {
            position: absolute;
            width: 40px;
            height: 40px;
            border: 2px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            display: none;
            z-index: 999;
        }
        #cursor-progress {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            border-radius: 50%;
            border: 3px solid #00ffff;
            border-top-color: transparent;
            border-right-color: transparent; /* ç®€å•çš„æ—‹è½¬åŠ¨ç”» */
            animation: spin 0.5s linear infinite;
            display: none;
        }
        @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        
        /* é€‰ä¸­å›¾ç‰‡çš„é¢„è§ˆå±‚ */
        #preview-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 200;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        #preview-overlay.active { opacity: 1; pointer-events: auto; }
        #preview-img {
            max-width: 80%; max-height: 80%;
            box-shadow: 0 0 30px rgba(255,255,255,0.2);
            border: 2px solid white;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="ui-layer">
        <label class="upload-btn">
            ğŸ“ å¯¼å…¥ç…§ç‰‡æ–‡ä»¶å¤¹
            <input type="file" id="folder-input" webkitdirectory directory multiple style="display: none;">
        </label>
        <br>
        <div id="status">æ­£åœ¨åˆå§‹åŒ– AI æ¨¡å‹...</div>
    </div>

    <div id="cursor-ring"><div id="cursor-progress"></div></div>

    <div id="preview-overlay" onclick="closePreview()">
        <img id="preview-img" src="">
    </div>

    <video class="input_video"></video>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- å…¨å±€é…ç½® ---
        const CONFIG = {
            cardCount: 150,       // ç…§ç‰‡å¡ç‰‡æ•°é‡ (æ‰¿è½½ç…§ç‰‡çš„å®ä½“)
            dustCount: 3000,      // æ°›å›´ç²’å­æ•°é‡
            heartScale: 15,       // çˆ±å¿ƒå¤§å°
            spreadRadius: 80,     // ç‚¸å¼€åçš„åŠå¾„
            animSpeed: 0.05,      // å˜å½¢é€Ÿåº¦
            hoverTime: 500,       // æ‚¬åœè§¦å‘æ—¶é—´ (ms)
        };

        // --- çŠ¶æ€å˜é‡ ---
        let state = {
            isOpen: false,        // æ‰‹æŒæ˜¯å¦å¼ å¼€
            hoveredObj: null,     // å½“å‰æ‚¬åœçš„å¯¹è±¡
            hoverStart: 0,        // æ‚¬åœå¼€å§‹æ—¶é—´
            images: [],           // åŠ è½½çš„å›¾ç‰‡çº¹ç†
            isPreviewing: false   // æ˜¯å¦æ­£åœ¨å…¨å±é¢„è§ˆ
        };

        let scene, camera, renderer, composer;
        let photoGroup, dustSystem; 
        let photoMeshes = []; // å­˜å‚¨æ‰€æœ‰çš„ç…§ç‰‡Mesh
        let raycaster, mouse;
        let handIndexPos = new THREE.Vector2(-100, -100); // æ‰‹æŒ‡å±å¹•åæ ‡
        
        // ç›®æ ‡ä½ç½®æ•°ç»„
        let targetPositions = []; // å­˜å‚¨ç…§ç‰‡Meshçš„ç›®æ ‡ä½ç½®

        // DOM å…ƒç´ 
        const statusDiv = document.getElementById('status');
        const cursorRing = document.getElementById('cursor-ring');
        const cursorProgress = document.getElementById('cursor-progress');
        const previewOverlay = document.getElementById('preview-overlay');
        const previewImg = document.getElementById('preview-img');

        initThree();
        initParticles();
        setupMediaPipe();
        setupUI();
        animate();

        // ==========================================
        // 1. Three.js åˆå§‹åŒ–
        // ==========================================
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.015);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 60;
            camera.position.y = 0;

            renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.body.appendChild(renderer.domElement);

            // åå¤„ç† - è¾‰å…‰
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.1;
            bloomPass.strength = 1.2;
            bloomPass.radius = 0.5;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                composer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        // ==========================================
        // 2. ç²’å­ç³»ç»Ÿ (ç…§ç‰‡å¡ç‰‡ + æ°›å›´å°˜åŸƒ)
        // ==========================================
        function initParticles() {
            // A. ç…§ç‰‡å¡ç‰‡ç»„ (Photo Cards) - ä½¿ç”¨ PlaneGeometry
            photoGroup = new THREE.Group();
            scene.add(photoGroup);

            const planeGeo = new THREE.PlaneGeometry(1, 1);
            
            for (let i = 0; i < CONFIG.cardCount; i++) {
                // é»˜è®¤æè´¨
                const mat = new THREE.MeshBasicMaterial({
                    color: new THREE.Color().setHSL(Math.random(), 0.8, 0.5),
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.8
                });
                
                const mesh = new THREE.Mesh(planeGeo, mat);
                mesh.userData = { 
                    id: i,
                    originPos: getHeartPosition(i, CONFIG.cardCount),
                    spreadPos: getSpherePosition(i, CONFIG.cardCount),
                    isPhoto: false,
                    scaleHeart: 0.3, // çˆ±å¿ƒæ¨¡å¼ä¸‹å¾ˆå°
                    scaleSpread: 6.0 // å±•å¼€æ¨¡å¼ä¸‹å˜å¤§
                };
                
                // åˆå§‹ä½ç½®è®¾ä¸ºçˆ±å¿ƒ
                mesh.position.copy(mesh.userData.originPos);
                mesh.scale.setScalar(mesh.userData.scaleHeart);
                
                // éšæœºæ—‹è½¬å¢åŠ è‡ªç„¶æ„Ÿ
                mesh.rotation.z = Math.random() * Math.PI;

                photoGroup.add(mesh);
                photoMeshes.push(mesh);
            }

            // B. æ°›å›´æ˜Ÿå°˜ (Dust) - ä½¿ç”¨ Points
            const dustGeo = new THREE.BufferGeometry();
            const dustPos = [];
            const dustColors = [];
            const color1 = new THREE.Color(0xff0055);
            const color2 = new THREE.Color(0xffaa00);

            for (let i = 0; i < CONFIG.dustCount; i++) {
                const pos = getHeartPosition(i, CONFIG.dustCount);
                // ç¨å¾®æŠ–åŠ¨ä¸€ä¸‹ä½ç½®ï¼Œè®©å°˜åŸƒçœ‹èµ·æ¥æ›´åšå®
                pos.x += (Math.random()-0.5) * 2;
                pos.y += (Math.random()-0.5) * 2;
                pos.z += (Math.random()-0.5) * 2;
                
                dustPos.push(pos.x, pos.y, pos.z);

                const c = color1.clone().lerp(color2, Math.random());
                dustColors.push(c.r, c.g, c.b);
            }

            dustGeo.setAttribute('position', new THREE.Float32BufferAttribute(dustPos, 3));
            dustGeo.setAttribute('color', new THREE.Float32BufferAttribute(dustColors, 3));

            const dustMat = new THREE.PointsMaterial({
                size: 0.3,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                transparent: true,
                opacity: 0.6
            });

            dustSystem = new THREE.Points(dustGeo, dustMat);
            scene.add(dustSystem);
        }

        // --- æ•°å­¦å…¬å¼ï¼šçˆ±å¿ƒ ---
        function getHeartPosition(idx, total) {
            // åˆ†å¸ƒåœ¨çˆ±å¿ƒè¡¨é¢çš„ç‚¹
            const t = Math.PI * 2 * Math.random();
            const u = Math.random(); 
            // ç®€å•çš„ Parametric Heart å˜ä½“
            const x = 16 * Math.pow(Math.sin(t), 3);
            const y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            // Zè½´åŠ åšåº¦
            const z = (Math.random() - 0.5) * 5; 

            const vec = new THREE.Vector3(x, y, z).multiplyScalar(0.8); // åŸºç¡€ç¼©æ”¾
            return vec;
        }

        // --- æ•°å­¦å…¬å¼ï¼šçƒä½“æ‰©æ•£ ---
        function getSpherePosition(idx, total) {
            const phi = Math.acos(-1 + (2 * idx) / total);
            const theta = Math.sqrt(total * Math.PI) * phi;
            
            const r = CONFIG.spreadRadius;
            const x = r * Math.cos(theta) * Math.sin(phi);
            const y = r * Math.sin(theta) * Math.sin(phi);
            const z = r * Math.cos(phi);
            
            return new THREE.Vector3(x, y, z);
        }

        // ==========================================
        // 3. MediaPipe æ‰‹åŠ¿è¯†åˆ«
        // ==========================================
        function setupMediaPipe() {
            const videoElement = document.getElementsByClassName('input_video')[0];

            const hands = new Hands({locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }});

            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.5
            });

            hands.onResults(onHandResults);

            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            cameraUtils.start()
                .then(() => statusDiv.innerText = "âœ¨ AI å°±ç»ªï¼šå¼ å¼€æ‰‹æŒæ‰©æ•£ï¼Œé£ŸæŒ‡é€‰æ‹©")
                .catch(err => statusDiv.innerText = "æ‘„åƒå¤´é”™è¯¯: " + err);
        }

        function onHandResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];

                // 1. åˆ¤æ–­å¼ å¼€è¿˜æ˜¯æ¡æ‹³ (è®¡ç®—æŒ‡å°–åˆ°æ‰‹è…•çš„å¹³å‡è·ç¦»)
                const wrist = landmarks[0];
                const tips = [4, 8, 12, 16, 20]; // æŒ‡å°–ç´¢å¼•
                let avgDist = 0;
                tips.forEach(idx => {
                    const d = Math.sqrt(
                        Math.pow(landmarks[idx].x - wrist.x, 2) + 
                        Math.pow(landmarks[idx].y - wrist.y, 2)
                    );
                    avgDist += d;
                });
                avgDist /= 5;

                // é˜ˆå€¼åˆ¤æ–­ (æ ¹æ®ç»éªŒï¼Œæ¡æ‹³çº¦ < 0.25ï¼Œå¼ å¼€ > 0.4)
                state.isOpen = avgDist > 0.35;

                // 2. è·å–é£ŸæŒ‡æŒ‡å°–åæ ‡ (Landmark 8) ç”¨äºäº¤äº’
                // MediaPipe x: 0(left)-1(right), y: 0(top)-1(bottom)
                // Need to mirror x
                const tipX = 1 - landmarks[8].x; 
                const tipY = landmarks[8].y;

                // æ˜ å°„åˆ°å±å¹•åæ ‡
                handIndexPos.set(
                    (tipX * 2) - 1, // NDC Space -1 to 1
                    -(tipY * 2) + 1
                );

                updateCursor(landmarks[8]);
            } else {
                state.isOpen = false;
                handIndexPos.set(-100, -100); // ç§»å‡ºå±å¹•
                cursorRing.style.display = 'none';
            }
        }

        // æ›´æ–° UI å…‰æ ‡ä½ç½®
        function updateCursor(landmark) {
            // å°†å½’ä¸€åŒ–åæ ‡è½¬æ¢ä¸ºåƒç´ åæ ‡
            // æ³¨æ„ï¼šMediaPipe è§†é¢‘æµå¯èƒ½å’Œçª—å£æ¯”ä¾‹ä¸åŒï¼Œè¿™é‡Œåšç®€å•æ˜ å°„
            const x = (1 - landmark.x) * window.innerWidth;
            const y = landmark.y * window.innerHeight;
            
            cursorRing.style.display = 'block';
            cursorRing.style.left = x + 'px';
            cursorRing.style.top = y + 'px';
        }


        // ==========================================
        // 4. é€»è¾‘æ›´æ–°ä¸åŠ¨ç”»
        // ==========================================
        function animate() {
            requestAnimationFrame(animate);

            if(state.isPreviewing) return; // é¢„è§ˆæš‚åœæ¸²æŸ“èŠ‚çœæ€§èƒ½

            // 1. ç²’å­å½¢æ€æ›´æ–° (Lerp)
            const dt = CONFIG.animSpeed;
            
            photoMeshes.forEach(mesh => {
                let target, targetScale, targetRot;

                if (state.isOpen) {
                    target = mesh.userData.spreadPos;
                    targetScale = mesh.userData.scaleSpread;
                    // å¼ å¼€æ—¶é¢å‘ç›¸æœº
                    mesh.lookAt(camera.position); 
                } else {
                    target = mesh.userData.originPos;
                    targetScale = mesh.userData.scaleHeart;
                    mesh.rotation.set(0, 0, mesh.rotation.z); // ä¿æŒä¸€ç‚¹éšæœº
                }

                // æ’å€¼ç§»åŠ¨
                mesh.position.lerp(target, dt);
                mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, 1), dt);
            });

            // 2. æ°›å›´ç²’å­åŠ¨æ€ (çˆ±å¿ƒè·³åŠ¨)
            const time = Date.now() * 0.002;
            if (!state.isOpen) {
                // å¿ƒè·³æ•ˆæœ
                const beat = 1 + Math.sin(time * 3) * 0.05;
                dustSystem.scale.setScalar(beat);
            } else {
                // æ‰©æ•£æ•ˆæœ
                dustSystem.scale.lerp(new THREE.Vector3(3,3,3), dt);
            }
            dustSystem.rotation.y = time * 0.1;

            // 3. é£ŸæŒ‡äº¤äº’æ£€æµ‹ (Raycasting)
            updateInteraction();

            // æ¸²æŸ“
            composer.render();
        }

        function updateInteraction() {
            if (!state.isOpen) {
                cursorProgress.style.display = 'none';
                return; // åªæœ‰å¼ å¼€æ—¶æ‰èƒ½é€‰ç…§ç‰‡
            }

            raycaster.setFromCamera(handIndexPos, camera);
            
            // æ£€æµ‹æ˜¯å¦ç¢°åˆ°ç…§ç‰‡ Mesh
            const intersects = raycaster.intersectObjects(photoMeshes);

            if (intersects.length > 0) {
                const hitObj = intersects[0].object;

                // ç¨å¾®æ”¾å¤§è¢«æ‚¬åœçš„ç‰©ä½“ä½œä¸ºåé¦ˆ
                hitObj.scale.multiplyScalar(1.1);

                if (state.hoveredObj !== hitObj) {
                    // æ–°çš„ç›®æ ‡
                    state.hoveredObj = hitObj;
                    state.hoverStart = Date.now();
                    cursorProgress.style.display = 'block';
                } else {
                    // æŒç»­æ‚¬åœ
                    const elapsed = Date.now() - state.hoverStart;
                    if (elapsed > CONFIG.hoverTime) {
                        // è§¦å‘æŸ¥çœ‹
                        openPreview(hitObj);
                        state.hoverStart = Date.now() + 999999; // é˜²æ­¢é‡å¤è§¦å‘
                        cursorProgress.style.display = 'none';
                    }
                }
            } else {
                state.hoveredObj = null;
                cursorProgress.style.display = 'none';
            }
        }

        // ==========================================
        // 5. å›¾ç‰‡å¤„ç†ä¸ UI
        // ==========================================
        function setupUI() {
            const input = document.getElementById('folder-input');
            input.addEventListener('change', handleFiles);

            window.closePreview = () => {
                previewOverlay.classList.remove('active');
                state.isPreviewing = false;
                animate(); // é‡å¯åŠ¨ç”»
            };
        }

        function handleFiles(event) {
            const files = Array.from(event.target.files).filter(f => f.type.startsWith('image/'));
            
            if (files.length === 0) {
                alert("æœªæ‰¾åˆ°å›¾ç‰‡æ–‡ä»¶");
                return;
            }

            statusDiv.innerText = `åŠ è½½äº† ${files.length} å¼ å›¾ç‰‡ï¼Œæ­£åœ¨ç”Ÿæˆçº¹ç†...`;

            // é™åˆ¶å¤„ç†æ•°é‡ï¼Œé˜²æ­¢å¡æ­»
            const limit = Math.min(files.length, CONFIG.cardCount);
            
            for (let i = 0; i < limit; i++) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.src = e.target.result;
                    img.onload = () => {
                        const texture = new THREE.Texture(img);
                        texture.needsUpdate = true;
                        texture.colorSpace = THREE.SRGBColorSpace;
                        
                        // åº”ç”¨åˆ° Mesh
                        const mesh = photoMeshes[i];
                        mesh.material.map = texture;
                        mesh.material.color.setHex(0xffffff); // å»æ‰æ··è‰²ï¼Œæ˜¾ç¤ºåŸå›¾
                        mesh.material.needsUpdate = true;
                        mesh.userData.isPhoto = true;
                        mesh.userData.imgSrc = e.target.result;
                    };
                };
                reader.readAsDataURL(files[i]);
            }
        }

        function openPreview(mesh) {
            if (!mesh.userData.isPhoto) return; // æ²¡å›¾ä¸æ‰“å¼€

            state.isPreviewing = true;
            previewImg.src = mesh.userData.imgSrc;
            previewOverlay.classList.add('active');
        }

    </script>
</body>
</html>