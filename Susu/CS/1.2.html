<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Hand Tracking Cosmic Particles</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        
        /* 视频元素隐藏，我们只读取数据 */
        #video-input {
            position: absolute;
            width: 1px; height: 1px;
            opacity: 0;
            pointer-events: none;
        }

        #ui-layer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 10;
        }

        #status {
            margin-top: 20px;
            color: #00ffaa;
            font-family: 'Courier New', monospace;
            font-size: 1.2rem;
            text-shadow: 0 0 10px #00ffaa;
            background: rgba(0,0,0,0.5);
            padding: 10px 20px;
            border: 1px solid #00ffaa;
        }

        .hud-info {
            position: absolute;
            bottom: 30px;
            color: rgba(255,255,255,0.6);
            font-family: sans-serif;
            font-size: 0.9rem;
            text-align: center;
            line-height: 1.6;
        }
        
        .gesture-icon {
            color: #ff0055;
            font-weight: bold;
        }
    </style>
</head>
<body>

<video id="video-input" autoplay playsinline></video>

<div id="ui-layer">
    <div id="status">Initializing AI Vision...</div>
    <div class="hud-info">
        [ 左 <-> 右移动 ] : 切换数学宇宙形态<br>
        [ <span class="gesture-icon">捏合手指</span> ] : 黑洞引力 &nbsp;|&nbsp; [ <span class="gesture-icon">张开手掌</span> ] : 星云斥力
    </div>
</div>

<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
      "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
    }
  }
</script>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { FilesetResolver, HandLandmarker } from "@mediapipe/tasks-vision";

// --- 配置 ---
const PARTICLE_COUNT = 60000; // 粒子数
const PARTICLE_SIZE = 1.8;
const CAM_Z = 100;

// --- 全局变量 ---
let scene, camera, renderer, composer;
let geometry, material, points;
let handLandmarker = undefined;
let videoElement = document.getElementById("video-input");
let lastVideoTime = -1;
let clock = new THREE.Clock();

// 交互状态
const interactionState = {
    hasHand: false,
    handPos: new THREE.Vector3(999, 999, 999), // 归一化坐标 (-1 to 1)
    pinchStrength: 0, // 0 = open, 1 = closed
    shapeProgress: 0  // 0 to 1 (x-axis position)
};

// 形状数据
const shapes = [];
const shapeNames = [
    "ORIGIN SPHERE", 
    "CHAOS VORTEX", 
    "KLEIN BOTTLE", 
    "TWISTED TORUS", 
    "ROSE SURFACE", 
    "MÖBIUS STRIP"
];

// --- 1. AI 视觉初始化 (MediaPipe) ---
async function initVision() {
    const statusDiv = document.getElementById('status');
    
    try {
        const vision = await FilesetResolver.forVisionTasks(
            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm"
        );
        
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
            baseOptions: {
                modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`,
                delegate: "GPU"
            },
            runningMode: "VIDEO",
            numHands: 1
        });
        
        statusDiv.innerText = "Camera Access Required...";
        startWebcam();
    } catch (e) {
        statusDiv.innerText = "Error Loading AI: " + e.message;
        console.error(e);
    }
}

function startWebcam() {
    const constraints = { video: { width: 640, height: 480, facingMode: "user" } };
    navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
        videoElement.srcObject = stream;
        videoElement.addEventListener("loadeddata", () => {
            document.getElementById('status').innerText = "SYSTEM READY - SHOW HAND";
            document.getElementById('status').style.color = "#fff";
            document.getElementById('status').style.borderColor = "#fff";
            predictWebcam();
        });
    }).catch(err => {
        document.getElementById('status').innerText = "Camera Denied.";
    });
}

async function predictWebcam() {
    if (handLandmarker && videoElement.currentTime !== lastVideoTime) {
        lastVideoTime = videoElement.currentTime;
        const startTimeMs = performance.now();
        const results = await handLandmarker.detectForVideo(videoElement, startTimeMs);

        if (results.landmarks && results.landmarks.length > 0) {
            const landmarks = results.landmarks[0]; // 只取第一只手
            
            interactionState.hasHand = true;

            // 1. 获取手掌中心 (用 Wrist(0) 和 MiddleMCP(9) 的中间点)
            // MediaPipe x: 0(left) -> 1(right), y: 0(top) -> 1(bottom)
            // 我们需要翻转 X (镜像) 并映射到 Three.js 坐标系
            const palmX = 1.0 - landmarks[9].x; 
            const palmY = 1.0 - landmarks[9].y; // 翻转Y以匹配WebGL
            
            // 映射到 NDC (-1 to 1)
            const ndcX = (palmX * 2) - 1;
            const ndcY = (palmY * 2) - 1;
            
            // 简单投影到世界坐标 (假设 z=0 平面)
            // 视野计算: height = 2 * tan(fov/2) * dist
            const dist = CAM_Z;
            const vFOV = THREE.MathUtils.degToRad(60);
            const height = 2 * Math.tan(vFOV / 2) * dist;
            const width = height * (window.innerWidth / window.innerHeight);
            
            interactionState.handPos.set(ndcX * width / 2, ndcY * height / 2, 0);

            // 2. 捏合检测 (Index Tip 8 vs Thumb Tip 4)
            const dx = landmarks[8].x - landmarks[4].x;
            const dy = landmarks[8].y - landmarks[4].y;
            const dz = landmarks[8].z - landmarks[4].z; // mediapipe z is relative depth
            const distance = Math.sqrt(dx*dx + dy*dy + dz*dz);
            
            // 距离 < 0.05 算捏合
            // 平滑过渡 pinchStrength
            const targetPinch = distance < 0.06 ? 1.0 : 0.0;
            interactionState.pinchStrength += (targetPinch - interactionState.pinchStrength) * 0.2;

            // 3. 形状切换 (基于 X 轴位置 0-1)
            interactionState.shapeProgress += (palmX - interactionState.shapeProgress) * 0.1;

        } else {
            interactionState.hasHand = false;
            // 没手的时候慢慢重置
            interactionState.pinchStrength *= 0.95;
        }
    }
    requestAnimationFrame(predictWebcam);
}

// --- 2. Three.js 场景初始化 ---
function initThree() {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.001);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, CAM_Z);

    renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // 后处理
    const renderScene = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    bloomPass.threshold = 0.1;
    bloomPass.strength = 1.5;
    bloomPass.radius = 0.5;
    
    composer = new EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    generateShapes();
    createParticles();

    window.addEventListener('resize', onResize);
    animate();
}

// --- 3. 生成数学形状 ---
function generateShapes() {
    const addShape = (fn) => {
        const data = new Float32Array(PARTICLE_COUNT * 3);
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const pt = fn(i, PARTICLE_COUNT);
            data[i*3] = pt.x; data[i*3+1] = pt.y; data[i*3+2] = pt.z;
        }
        shapes.push(data);
    };

    // 0. Sphere (Origin)
    addShape((i, count) => {
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos((Math.random() * 2) - 1);
        const r = 35;
        return {x: r*Math.sin(phi)*Math.cos(theta), y: r*Math.sin(phi)*Math.sin(theta), z: r*Math.cos(phi)};
    });

    // 1. Chaos Vortex
    addShape((i, count) => {
        const t = i * 0.01;
        const r = (i/count) * 40;
        return { x: r*Math.cos(t), y: (i/count)*60 - 30, z: r*Math.sin(t) };
    });

    // 2. Klein Bottle
    addShape((i, count) => {
        const u = (i/count) * Math.PI * 2;
        const v = (i % 100)/100 * Math.PI * 2;
        const r = 4 * (1 - Math.cos(u)/2);
        let x,y,z;
        if(u < Math.PI) {
            x = 6*Math.cos(u)*(1+Math.sin(u)) + r*Math.cos(u)*Math.cos(v);
            y = 16*Math.sin(u) + r*Math.sin(u)*Math.cos(v);
        } else {
            x = 6*Math.cos(u)*(1+Math.sin(u)) + r*Math.cos(v+Math.PI);
            y = 16*Math.sin(u);
        }
        z = r*Math.sin(v);
        return {x: x*1.3, y: y*1.3, z: z*1.3};
    });

    // 3. Twisted Torus
    addShape((i, count) => {
        const u = (i/count) * Math.PI * 10;
        const v = (i % 200)/200 * Math.PI * 2;
        const R = 30 + 5*Math.sin(u*2);
        const r = 8;
        return {
            x: (R + r*Math.cos(v)) * Math.cos(u),
            y: (R + r*Math.cos(v)) * Math.sin(u),
            z: r*Math.sin(v) + Math.sin(u)*10
        };
    });

    // 4. Rose Surface
    addShape((i, count) => {
        const theta = (i/count) * Math.PI * 2 * 10;
        const phi = (i % 100)/100 * Math.PI;
        const r = 30 * Math.sin(3*theta);
        return {
            x: r * Math.sin(phi) * Math.cos(theta),
            y: r * Math.cos(phi),
            z: r * Math.sin(phi) * Math.sin(theta)
        };
    });
    
    // 5. Möbius Strip
    addShape((i, count) => {
        const u = (i/count) * Math.PI * 2; 
        const v = ((Math.random()*2)-1) * 8;
        return {
            x: (30 + v*Math.cos(u/2)) * Math.cos(u),
            y: (30 + v*Math.cos(u/2)) * Math.sin(u),
            z: v*Math.sin(u/2)
        };
    });
}

// --- 4. 粒子系统 (Shader) ---
function createParticles() {
    geometry = new THREE.BufferGeometry();
    
    // 我们需要把所有形状数据都传进去，或者动态混合
    // 由于WebGL Attribute限制，我们这里做一种巧妙的方法：
    // 传入两个 Attribute: posA, posB
    // 在 JS 中根据 progress 动态更新这两个 Attribute 的内容
    
    const pos = new Float32Array(shapes[0]);
    const col = new Float32Array(PARTICLE_COUNT*3);
    
    const c1 = new THREE.Color(0x00ffff);
    const c2 = new THREE.Color(0xff00ff);
    for(let i=0; i<PARTICLE_COUNT; i++) {
        const c = c1.clone().lerp(c2, Math.random());
        col[i*3] = c.r; col[i*3+1] = c.g; col[i*3+2] = c.b;
    }
    
    geometry.setAttribute('position', new THREE.BufferAttribute(pos, 3));
    geometry.setAttribute('targetPosition', new THREE.BufferAttribute(new Float32Array(shapes[1]), 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(col, 3));

    material = new THREE.ShaderMaterial({
        uniforms: {
            uTime: { value: 0 },
            uMix: { value: 0 }, // 0 = position, 1 = targetPosition
            uSize: { value: PARTICLE_SIZE * window.devicePixelRatio },
            uHandPos: { value: new THREE.Vector3(0,0,0) },
            uPinchStrength: { value: 0 }, // 0 = open (repel), 1 = closed (attract)
            uHasHand: { value: 0 }
        },
        vertexShader: `
            uniform float uTime;
            uniform float uMix;
            uniform float uSize;
            uniform vec3 uHandPos;
            uniform float uPinchStrength;
            uniform float uHasHand;
            
            attribute vec3 targetPosition;
            attribute vec3 color;
            varying vec3 vColor;
            
            // Simplex Noise Function
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            float snoise(vec3 v) { 
                const vec2  C = vec2(1.0/6.0, 1.0/3.0);
                const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
                vec3 i  = floor(v + dot(v, C.yyy) );
                vec3 x0 = v - i + dot(i, C.xxx) ;
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                i = mod289(i); 
                vec4 p = permute( permute( permute( 
                            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                          + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                          + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                float n_ = 0.142857142857; 
                vec3  ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ );
                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
            }

            void main() {
                vColor = color;
                
                // 1. 形状混合
                vec3 pos = mix(position, targetPosition, uMix);
                
                // 2. 交互物理
                if (uHasHand > 0.5) {
                    float d = distance(pos, uHandPos);
                    float radius = 40.0; // 交互半径
                    
                    if (d < radius) {
                        vec3 dir = normalize(pos - uHandPos);
                        
                        // 计算力
                        // pinchStrength: 0 (Open) -> Repel (推开)
                        // pinchStrength: 1 (Closed) -> Attract (吸入)
                        
                        float forceFactor = (radius - d) / radius; // 0..1
                        
                        // 斥力模式 (Open)
                        float repelForce = 20.0 * forceFactor * (1.0 - uPinchStrength);
                        
                        // 引力模式 (Pinch) - 负值吸入
                        float attractForce = -50.0 * forceFactor * uPinchStrength;
                        
                        // 组合力
                        float totalForce = repelForce + attractForce;
                        
                        // 应用位移
                        pos += dir * totalForce;
                        
                        // 添加一点漩涡/噪声
                        float noise = snoise(pos * 0.05 + uTime * 2.0);
                        pos += cross(dir, vec3(0,1,0)) * noise * 5.0 * forceFactor;
                        
                        // 交互高亮
                        vColor += vec3(0.5, 0.5, 1.0) * forceFactor;
                    }
                }
                
                // 3. 自然呼吸
                pos += vec3(sin(uTime + pos.y*0.1), cos(uTime*0.8 + pos.x*0.1), 0.0) * 0.2;

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = uSize * (60.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `,
        fragmentShader: `
            varying vec3 vColor;
            void main() {
                vec2 uv = gl_PointCoord - 0.5;
                float d = length(uv);
                if (d > 0.5) discard;
                float alpha = 1.0 - smoothstep(0.1, 0.5, d);
                gl_FragColor = vec4(vColor, alpha);
            }
        `,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending
    });

    points = new THREE.Points(geometry, material);
    scene.add(points);
}

// --- 5. 动画循环 ---
let currentBaseShapeIndex = 0;

function animate() {
    requestAnimationFrame(animate);
    
    const time = clock.getElapsedTime();
    material.uniforms.uTime.value = time;
    
    // 更新交互 Uniforms
    material.uniforms.uHandPos.value.lerp(interactionState.handPos, 0.1);
    material.uniforms.uHasHand.value = interactionState.hasHand ? 1.0 : 0.0;
    material.uniforms.uPinchStrength.value = interactionState.pinchStrength;

    // --- 形状切换逻辑 (基于手掌位置 Scroll) ---
    // progress 0~1. 映射到 shapes 数组
    // 比如 0.0-0.2 -> Shape 0 to Shape 1
    
    const totalShapes = shapes.length;
    const scrollVal = Math.max(0, Math.min(1, interactionState.shapeProgress)) * (totalShapes - 1);
    
    const baseIndex = Math.floor(scrollVal); // 当前左侧形状索引
    const nextIndex = Math.min(baseIndex + 1, totalShapes - 1); // 目标形状索引
    const mixFactor = scrollVal - baseIndex; // 小数部分作为混合因子
    
    // 只有当基础索引改变时才更新 Attribute，以节省性能
    // 但因为 BufferAttribute 更新开销大，我们最好只在发生大变动时更新
    // 简化方案：每一帧如果 baseIndex 变了，就上传新数据。
    
    if (baseIndex !== currentBaseShapeIndex) {
        // 更新 Attribute
        geometry.attributes.position.array.set(shapes[baseIndex]);
        geometry.attributes.targetPosition.array.set(shapes[nextIndex]);
        
        geometry.attributes.position.needsUpdate = true;
        geometry.attributes.targetPosition.needsUpdate = true;
        
        currentBaseShapeIndex = baseIndex;
        
        // 更新 UI 文本
        const statusEl = document.getElementById('status');
        if (interactionState.hasHand) {
             statusEl.innerText = `${shapeNames[baseIndex]} -> ${shapeNames[nextIndex]}`;
        }
    }
    
    // 设置 Shader 混合因子
    material.uniforms.uMix.value = mixFactor;
    
    // 只有在没手的时候自动旋转
    if (!interactionState.hasHand) {
        points.rotation.y += 0.001;
    } else {
        // 有手的时候稍微根据手的位置倾斜场景
        const targetRotX = interactionState.handPos.y * 0.005;
        const targetRotY = interactionState.handPos.x * 0.005;
        points.rotation.x += (targetRotX - points.rotation.x) * 0.05;
        points.rotation.y += (targetRotY - points.rotation.y) * 0.05;
    }

    composer.render();
}

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
}

// 启动
initVision();
initThree();

</script>
</body>
</html>