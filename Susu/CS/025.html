<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js æŒæ§æ˜Ÿè¾°</title>
    <style>
        :root {
            --primary: #00f2ff;
            --panel-bg: rgba(10, 10, 15, 0.75);
            --border-color: rgba(255, 255, 255, 0.15);
        }

        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; color: white; }
        
        /* è§†é¢‘éšè— */
        #video-input { display: none; transform: scaleX(-1); }

        /* ç”»å¸ƒ */
        #canvas-container {
            position: absolute; inset: 0; z-index: 1;
            background: radial-gradient(circle at center, #161625 0%, #000000 100%);
        }

        /* ç°ä»£ UI é¢æ¿ */
        #ui-panel {
            position: absolute; top: 20px; right: 20px; width: 260px;
            background: var(--panel-bg);
            backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
            border: 1px solid var(--border-color);
            border-radius: 16px; padding: 24px; z-index: 10;
            box-shadow: 0 20px 50px rgba(0,0,0,0.6);
            transition: opacity 0.3s;
        }

        h2 {
            margin: 0 0 20px 0; font-size: 14px; text-transform: uppercase;
            letter-spacing: 3px; color: var(--primary); text-align: center;
            border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 12px;
        }

        /* æŒ‰é’®ç½‘æ ¼ */
        .grid-buttons { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 20px; }
        
        button {
            background: rgba(255,255,255,0.05); border: 1px solid transparent;
            color: #ccc; padding: 10px; border-radius: 8px; cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); font-size: 12px;
        }
        button:hover { background: rgba(255,255,255,0.15); border-color: rgba(255,255,255,0.3); }
        button.active {
            background: var(--primary); color: #000; font-weight: 800;
            box-shadow: 0 0 15px rgba(0, 242, 255, 0.4); border-color: var(--primary);
        }

        /* çŠ¶æ€æ¡ */
        .status-bar {
            margin-top: 15px; padding: 12px; border-radius: 8px;
            background: rgba(0,0,0,0.4); font-size: 12px; text-align: center;
            border-left: 3px solid #666; transition: 0.3s;
            display: flex; justify-content: space-between; align-items: center;
        }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #666; transition:0.3s; }
        
        /* åŠ è½½åŠ¨ç”» */
        #loader {
            position: fixed; inset: 0; background: #000; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .orbit-spinner {
            width: 50px; height: 50px; border: 2px solid #333; border-radius: 50%;
            border-top-color: var(--primary); animation: spin 1s infinite linear;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>

    <!-- ä¾èµ– -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

<div id="loader">
    <div class="orbit-spinner"></div>
    <p style="color:#666; margin-top:20px; font-size:12px; letter-spacing:1px;">æ­£åœ¨åˆå§‹åŒ–è§†è§‰æ ¸å¿ƒ...</p>
</div>

<div id="ui-panel">
    <h2>ç²’å­æ“æ§å°</h2>
    
    <div class="grid-buttons">
        <button onclick="setShape('sphere')" class="active" id="btn-sphere">ğŸ”® çµçƒ</button>
        <button onclick="setShape('heart')" id="btn-heart">â¤ï¸ æ ¸å¿ƒ</button>
        <button onclick="setShape('galaxy')" id="btn-galaxy">ğŸŒŒ æ¼©æ¶¡</button>
        <button onclick="setShape('cube')" id="btn-cube">ğŸ§Š çŸ©é˜µ</button>
        <button onclick="setShape('ring')" id="btn-ring">ğŸª æ˜Ÿç¯</button>
        <button onclick="setShape('shield')" id="btn-shield">ğŸ›¡ï¸ æŠ¤ç›¾</button>
    </div>

    <div style="margin-bottom: 15px;">
        <label style="font-size:12px; color:#888; display:block; margin-bottom:5px;">ç²’å­å…‰è°±</label>
        <input type="color" id="colorPicker" value="#00f2ff" style="width:100%; height:30px; border:none; cursor:pointer; background:none;">
    </div>

    <div class="status-bar" id="status-box">
        <span id="status-text">ç­‰å¾…æ‰‹éƒ¨...</span>
        <div class="status-dot" id="status-dot"></div>
    </div>
</div>

<video id="video-input"></video>
<div id="canvas-container"></div>

<script>
    // --- 1. åœºæ™¯åˆå§‹åŒ– ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.001); // æ·±åº¦é›¾

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 50;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // --- 2. ç²’å­æ ¸å¿ƒé€»è¾‘ (å…³é”®ä¿®æ”¹) ---
    const count = 20000; // ç²’å­æ€»æ•°
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);
    
    // ä¸¤ä¸ªæ ¸å¿ƒæ•°æ®é›†ï¼š
    // 1. worldPositions: å¯¹åº”â€œå…¨å±æ‰©æ•£â€ï¼Œç²’å­åˆ†å¸ƒåœ¨æ•´ä¸ª 3D ç©ºé—´
    // 2. shapePositions: å¯¹åº”â€œæ‰‹éƒ¨èšæ‹¢â€ï¼Œç²’å­æ„æˆç‰¹å®šå½¢çŠ¶çš„ç›¸å¯¹åæ ‡
    const worldPositions = new Float32Array(count * 3);
    const shapesData = {}; // ç¼“å­˜æ‰€æœ‰å½¢çŠ¶æ•°æ®

    // å·¥å…·å‡½æ•°ï¼šç”Ÿæˆçƒé¢ä¸Šçš„ä¸€ç‚¹
    function getSpherePoint(r) {
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);
        return {
            x: r * Math.sin(phi) * Math.cos(theta),
            y: r * Math.sin(phi) * Math.sin(theta),
            z: r * Math.cos(phi)
        };
    }

    // åˆå§‹åŒ– World Positions (å…¨å±æ˜Ÿç©º)
    for(let i=0; i<count; i++) {
        // åœ¨ä¸€ä¸ªå·¨å¤§çš„é•¿æ–¹ä½“èŒƒå›´å†…éšæœºåˆ†å¸ƒï¼Œè¦†ç›–è§†é‡
        worldPositions[i*3] = (Math.random() - 0.5) * 180;   // å®½è¦†ç›–
        worldPositions[i*3+1] = (Math.random() - 0.5) * 100; // é«˜è¦†ç›–
        worldPositions[i*3+2] = (Math.random() - 0.5) * 100; // æ·±åº¦
        
        // åˆå§‹ä½ç½® = å…¨å±
        positions[i*3] = worldPositions[i*3];
        positions[i*3+1] = worldPositions[i*3+1];
        positions[i*3+2] = worldPositions[i*3+2];
    }

    // é¢„è®¡ç®—å½¢çŠ¶æ•°æ®
    function generateShape(type) {
        const data = new Float32Array(count * 3);
        for(let i=0; i<count; i++) {
            let x=0, y=0, z=0;
            if (type === 'sphere') {
                const p = getSpherePoint(12);
                x=p.x; y=p.y; z=p.z;
            } 
            else if (type === 'heart') {
                const t = Math.random() * Math.PI * 2;
                // ç¨å¾®æ”¾å¤§ä¸€ç‚¹å¿ƒå½¢
                x = 1.2 * 16 * Math.pow(Math.sin(t), 3);
                y = 1.2 * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                z = (Math.random()-0.5) * 5;
                // å†…éƒ¨å¡«å……
                const s = Math.random();
                x*=s; y=(y*s)+3; z*=s;
            }
            else if (type === 'galaxy') {
                const angle = Math.random() * Math.PI * 2 * 3;
                const r = Math.random() * 25;
                x = Math.cos(angle + r*0.1) * r;
                y = (Math.random()-0.5) * (20-r) * 0.5; // ä¸­å¿ƒåšè¾¹ç¼˜è–„
                z = Math.sin(angle + r*0.1) * r;
            }
            else if (type === 'cube') {
                const size = 20;
                x = (Math.random()-0.5)*size;
                y = (Math.random()-0.5)*size;
                z = (Math.random()-0.5)*size;
            }
            else if (type === 'ring') {
                const angle = Math.random() * Math.PI * 2;
                const r = 15 + Math.random() * 5;
                x = Math.cos(angle) * r;
                y = (Math.random()-0.5) * 1;
                z = Math.sin(angle) * r;
                // å¢åŠ ä¸€äº›å†…éƒ¨æ¼‚æµ®ç‚¹
                if(i % 10 === 0) { x*=0.5; z*=0.5; y=(Math.random()-0.5)*10; }
            }
            else if (type === 'shield') {
                // åŠçƒæŠ¤ç›¾
                const p = getSpherePoint(14);
                if(p.z < 0) p.z = -p.z * 0.2; // å‹å¹³èƒŒé¢
                x=p.x; y=p.y; z=p.z;
            }

            data[i*3] = x;
            data[i*3+1] = y;
            data[i*3+2] = z;
        }
        return data;
    }

    // ç”Ÿæˆæ‰€æœ‰å½¢çŠ¶
    ['sphere', 'heart', 'galaxy', 'cube', 'ring', 'shield'].forEach(t => {
        shapesData[t] = generateShape(t);
    });

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png');
    const material = new THREE.PointsMaterial({
        size: 0.6,
        color: 0x00f2ff,
        map: sprite,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- 3. çŠ¶æ€ç®¡ç† ---
    let currentShape = shapesData['sphere'];
    let handPos = new THREE.Vector3(0,0,0);
    let smoothHandPos = new THREE.Vector3(0,0,0);
    // handPower: 0 = æ•£å¼€(å…¨å±), 1 = èšæ‹¢(æ‰‹ä¸­)
    let handPower = 0; 
    let isTracked = false;

    // UI äº¤äº’
    window.setShape = (name) => {
        currentShape = shapesData[name];
        document.querySelectorAll('.grid-buttons button').forEach(b => b.classList.remove('active'));
        document.getElementById('btn-'+name).classList.add('active');
    };
    document.getElementById('colorPicker').addEventListener('input', e => material.color.set(e.target.value));

    // --- 4. è§†è§‰è¯†åˆ« (MediaPipe) ---
    const statusBox = document.getElementById('status-box');
    const statusText = document.getElementById('status-text');
    const statusDot = document.getElementById('status-dot');

    function onResults(results) {
        document.getElementById('loader').style.display = 'none';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            isTracked = true;
            const lm = results.multiHandLandmarks[0];

            // è®¡ç®—æ‰‹å¿ƒ (ä¸­æŒ‡æ ¹éƒ¨9)
            // åæ ‡æ˜ å°„ï¼šMediaPipe(0~1) -> Three.js World(-x~+x)
            // åšäº†é•œåƒç¿»è½¬ (0.5 - x)
            const wx = (0.5 - lm[9].x) * 90; 
            const wy = (0.5 - lm[9].y) * 60;
            handPos.set(wx, wy, 0);

            // è®¡ç®—æåˆç¨‹åº¦ (æ‹‡æŒ‡4 - é£ŸæŒ‡8)
            const pinchDist = Math.sqrt(
                Math.pow(lm[4].x - lm[8].x, 2) + Math.pow(lm[4].y - lm[8].y, 2)
            );
            
            // æ˜ å°„é€»è¾‘ï¼š
            // è·ç¦» < 0.05 (æåˆ) -> Power 1.0 (èšæ‹¢)
            // è·ç¦» > 0.15 (å¼ å¼€) -> Power 0.0 (å…¨å±)
            let targetPower = (pinchDist - 0.04) / 0.12;
            targetPower = 1.0 - Math.min(1, Math.max(0, targetPower)); // Clamp & Invert

            // ç¼“åŠ¨
            handPower += (targetPower - handPower) * 0.1;

            // UI æ›´æ–°
            if(handPower > 0.6) {
                statusText.innerText = "çŠ¶æ€ï¼šå‡èš (HOLD)";
                statusText.style.color = "#00ff88";
                statusBox.style.borderLeftColor = "#00ff88";
                statusDot.style.background = "#00ff88";
                statusDot.style.boxShadow = "0 0 10px #00ff88";
            } else {
                statusText.innerText = "çŠ¶æ€ï¼šé‡Šæ”¾ (FREE)";
                statusText.style.color = "#00f2ff";
                statusBox.style.borderLeftColor = "#00f2ff";
                statusDot.style.background = "#00f2ff";
                statusDot.style.boxShadow = "none";
            }

        } else {
            isTracked = false;
            // æ— æ‰‹æ—¶ï¼Œç¼“æ…¢å½’é›¶(å…¨å±)
            handPower += (0 - handPower) * 0.05;
            statusText.innerText = "å¯»æ‰¾æ‰‹éƒ¨ä¿¡å·...";
            statusText.style.color = "#aaa";
            statusBox.style.borderLeftColor = "#555";
            statusDot.style.background = "#555";
            statusDot.style.boxShadow = "none";
        }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
    hands.onResults(onResults);
    
    const cam = new Camera(document.getElementById('video-input'), {
        onFrame: async () => await hands.send({image: document.getElementById('video-input')}),
        width: 640, height: 480
    });
    cam.start();

    // --- 5. åŠ¨ç”»å¾ªç¯ (æ ¸å¿ƒæ•ˆæœ) ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();
        
        // å¹³æ»‘æ‰‹éƒ¨ä½ç½®
        smoothHandPos.lerp(handPos, 0.15);

        const posArr = particles.geometry.attributes.position.array;
        
        // åœºæ™¯å¾®åŠ¨
        particles.rotation.y = time * 0.03;

        // æ ¸å¿ƒæ··åˆç®—æ³•ï¼š
        // Pos = Lerp( WorldPos, HandPos + ShapeOffset, HandPower )
        
        for(let i=0; i<count; i++) {
            const idx = i*3;

            // A: å…¨å±çŠ¶æ€ä¸‹çš„åæ ‡ (ä¸–ç•Œåæ ‡)
            // åŠ ä¸Šä¸€ç‚¹æ­£å¼¦æ³¢æµ®åŠ¨ï¼Œè®©æ˜Ÿç©ºçœ‹èµ·æ¥æ˜¯æ´»çš„
            const wx = worldPositions[idx];
            const wy = worldPositions[idx+1] + Math.sin(time + wx)*2; 
            const wz = worldPositions[idx+2];

            // B: èšæ‹¢çŠ¶æ€ä¸‹çš„åæ ‡ (æ‰‹å¿ƒ + å½¢çŠ¶åç§»)
            const sx = smoothHandPos.x + currentShape[idx];
            const sy = smoothHandPos.y + currentShape[idx+1];
            const sz = smoothHandPos.z + currentShape[idx+2];

            // æ’å€¼è®¡ç®—
            // ç²’å­å½“å‰ä½ç½® = ä» A æ»‘åŠ¨åˆ° B
            // æˆ‘ä»¬ä¸ç›´æ¥è®¾ç½®ä½ç½®ï¼Œè€Œæ˜¯ä½¿ç”¨ç¼“åŠ¨é€¼è¿‘ç›®æ ‡ï¼Œè¿™æ ·çœ‹èµ·æ¥æ›´æœ‰"é£è¡Œ"çš„æ„Ÿè§‰
            
            // è®¡ç®—å½“å‰ç²’å­çš„"ç†æƒ³"ç›®æ ‡
            const targetX = wx + (sx - wx) * handPower;
            const targetY = wy + (sy - wy) * handPower;
            const targetZ = wz + (sz - wz) * handPower;
            
            // æ¯ä¸€å¸§ç§»åŠ¨ 10% çš„è·ç¦»å»è¿½èµ¶ç›®æ ‡
            posArr[idx] += (targetX - posArr[idx]) * 0.1;
            posArr[idx+1] += (targetY - posArr[idx+1]) * 0.1;
            posArr[idx+2] += (targetZ - posArr[idx+2]) * 0.1;
        }
        
        // åŠ¨æ€å¤§å°ï¼šæ•£å¼€æ—¶å¦‚ç¹æ˜Ÿ(å°)ï¼Œèšæ‹¢æ—¶å¦‚èƒ½é‡å—(å¤§)
        // material.size = 0.4 + handPower * 0.5;
        // åè¿‡æ¥ä¹Ÿå¯ä»¥ï¼šæ•£å¼€æ—¶ä¸ºäº†çœ‹æ¸…èƒŒæ™¯å¯ä»¥ç¨å¾®å¤§ä¸€ç‚¹ï¼Œæˆ–è€…ä¿æŒä¸€è‡´
        material.size = 0.6; // ä¿æŒä¸€è‡´çœ‹èµ·æ¥æ¯”è¾ƒç¨³

        particles.geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>