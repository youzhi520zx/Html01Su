<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Cosmic Math - Frontal View</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; }
        
        #ui-container {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }

        #title {
            color: rgba(255, 255, 255, 0.9);
            font-size: 18px;
            text-shadow: 0 0 10px #00ffff;
            margin-bottom: 10px;
        }

        #status {
            color: #ffff00;
            font-size: 14px;
            background: rgba(0,0,0,0.6);
            padding: 5px 10px;
            border-radius: 4px;
            display: inline-block;
        }

        #instruction {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.6);
            font-size: 12px;
            pointer-events: none;
        }
        
        #input-video { display: none; }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            animation: pulse 1s infinite;
            z-index: 100;
        }

        @keyframes pulse {
            0% { opacity: 0.5; }
            100% { opacity: 1; text-shadow: 0 0 20px cyan; }
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

<div id="loading" class="loading">æ­£åœ¨æ ¡å‡†æ•°å­¦æ¨¡å‹...<br><span style="font-size:14px">è¯·æˆäºˆæ‘„åƒå¤´æƒé™</span></div>

<div id="ui-container">
    <div id="title">COSMIC MATH - FRONTAL VIEW</div>
    <div id="status">ç­‰å¾…æ‰‹åŠ¿æŒ‡ä»¤...</div>
</div>

<div id="instruction">
    ğŸ–ï¸ 1-5æŒ‡åˆ‡æ¢æ­£é¢å½¢æ€ | ğŸ‘Œ æåˆåç¼© | ğŸ‘‹ æŒ¥æ‰‹ç§»åŠ¨ä½ç½®
</div>

<audio id="bgm" loop>
    <source src="https://cdn.pixabay.com/download/audio/2022/03/10/audio_c8c8a73467.mp3?filename=cosmic-glow-14282.mp3" type="audio/mp3">
</audio>

<video id="input-video"></video>

<script>
    // --- 1. åœºæ™¯è®¾ç½® ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.0006);

    const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 1, 20000);
    // ç›¸æœºä½ç½®å›ºå®šåœ¨æ­£å‰æ–¹ï¼Œç¡®ä¿â€œæ­£é¢â€è§†è§’
    camera.position.z = 1200;
    camera.position.y = 0;
    camera.position.x = 0;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // --- 2. ç²’å­ç³»ç»Ÿ ---
    const particleCount = 22000;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const targetPositions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    const colorObj = new THREE.Color();

    for (let i = 0; i < particleCount; i++) {
        // åˆå§‹é“ºæ»¡å±å¹•
        positions[i * 3] = (Math.random() - 0.5) * 2000;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 1200;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 500;
        
        targetPositions[i] = positions[i];

        colorObj.setHSL(Math.random(), 0.8, 0.5);
        colors[i * 3] = colorObj.r;
        colors[i * 3 + 1] = colorObj.g;
        colors[i * 3 + 2] = colorObj.b;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    function getTexture() {
        const c = document.createElement('canvas');
        c.width = 32; c.height = 32;
        const ctx = c.getContext('2d');
        const g = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        g.addColorStop(0, 'rgba(255,255,255,1)');
        g.addColorStop(0.2, 'rgba(200,240,255,0.6)');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g;
        ctx.fillRect(0,0,32,32);
        const t = new THREE.Texture(c);
        t.needsUpdate = true;
        return t;
    }

    const material = new THREE.PointsMaterial({
        size: 9, // ç¨å¾®è°ƒå¤§ä¸€ç‚¹ç‚¹
        map: getTexture(),
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.85
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- 3. ä¿®æ­£åçš„æ•°å­¦å½¢æ€ (XY å¹³é¢ä¼˜å…ˆ) ---
    function getShapePos(shapeIndex, i) {
        // t æ˜ å°„åˆ° 0 -> 2PI (æˆ–è€…æ›´å¤šåœˆ)
        const t = (i / particleCount) * Math.PI * 2;
        
        // å¢åŠ  randomness å˜é‡ï¼Œç”¨äºåˆ¶é€ åšåº¦ (Zè½´)
        const rnd = (Math.random() - 0.5); 
        
        let x=0, y=0, z=0;

        switch (shapeIndex) {
            case 0: // 0æŒ‡/æåˆ: é»‘æ´ (ä¿æŒçƒä½“ï¼Œä½†ä¹Ÿç¨å¾®å‹æ‰ä¸€ç‚¹åƒåœ†ç›˜)
                const r = 200 * Math.random(); 
                const theta = Math.random() * Math.PI * 2;
                x = r * Math.cos(theta);
                y = r * Math.sin(theta);
                z = (Math.random() - 0.5) * 50; // æ‰å¹³å¸ç§¯ç›˜
                break;

            case 1: // 1æŒ‡: è´¹é©¬èºæ—‹/æ˜Ÿç³»ç›˜ (æ­£é¢æœå‘)
                // ä¹‹å‰æ˜¯é¾™å·é£ï¼Œç°åœ¨æ”¹æˆæ­£é¢çœ‹åˆ°çš„æ¼©æ¶¡
                const spiralR = 30 * Math.sqrt(i); // è´¹é©¬èºæ—‹åˆ†å¸ƒ
                const spiralA = i * 0.1;
                x = spiralR * Math.cos(spiralA) * 0.4;
                y = spiralR * Math.sin(spiralA) * 0.4;
                z = rnd * 50; // åšåº¦
                break;

            case 2: // 2æŒ‡: åŒæ‰­çº¿ (Infinity) - æ­£é¢
                const lt = t * 20; // å¢åŠ å¯†åº¦
                const scaleL = 500;
                const denom = 1 + Math.sin(lt) * Math.sin(lt);
                x = scaleL * Math.cos(lt) / denom;
                y = scaleL * Math.sin(lt) * Math.cos(lt) / denom;
                z = rnd * 100; // åšåº¦
                break;
            
            case 3: // 3æŒ‡: è´è¶ (Butterfly) - æ­£é¢
                const bt = t * 12;
                // ä¿®æ­£äº†Yè½´æ–¹å‘ï¼Œç¡®ä¿è´è¶å¤´æœä¸Š
                const br = 180 * (Math.exp(Math.cos(bt)) - 2*Math.cos(4*bt) - Math.pow(Math.sin(bt/12),5));
                x = br * Math.sin(bt); 
                y = br * Math.cos(bt); 
                z = rnd * 80;
                break;

            case 4: // 4æŒ‡: ç«ç‘°çº¿ (Rose) - æ­£é¢
                // ä¹‹å‰æ˜¯èººå¹³çš„ï¼Œç°åœ¨ç«‹èµ·æ¥ (æ˜ å°„åˆ° XY)
                const k = 6; // 6ç“£èŠ±
                const rr = 500 * Math.cos(k * t * 2);
                x = rr * Math.cos(t * 2);
                y = rr * Math.sin(t * 2);
                z = rnd * 150 + Math.sin(t*10)*50; // èŠ±ç“£èµ·ä¼
                break;

            case 5: // 5æŒ‡: å®Œç¾çˆ±å¿ƒ (Heart) - æ­£é¢
            default:
                // ä½¿ç”¨æ ‡å‡†çš„ 2D Heart æ–¹ç¨‹ï¼Œä¸å†æ—‹è½¬
                const ht = t * 2; // 0-4PI range
                x = 16 * 18 * Math.pow(Math.sin(ht), 3);
                y = 16 * (13 * Math.cos(ht) - 5 * Math.cos(2*ht) - 2 * Math.cos(3*ht) - Math.cos(4*ht));
                // Heartå…¬å¼é»˜è®¤æ˜¯æ­£çš„ï¼Œä½†ThreeJSé‡ŒYå‘ä¸Šï¼Œè¿™ä¸ªå…¬å¼åˆšå¥½æ­£å‘
                // å¢åŠ ä¸€ç‚¹ Z è½´ä½“ç§¯ï¼Œè®©å®ƒåƒä¸ªå……æ°”æ°”çƒ
                z = rnd * 120 * (1 - Math.abs(x)/400); // ä¸­é—´åšè¾¹ç¼˜è–„
                break;
        }
        return {x, y, z};
    }

    // --- 4. æ‰‹åŠ¿äº¤äº’ ---
    let handX = 0, handY = 0;
    let isPinching = false;
    let fingerCount = 5;
    let currentShapeIndex = 5;
    let lastShapeIndex = -1;

    const videoElement = document.getElementById('input-video');
    const statusDiv = document.getElementById('status');
    const loadingDiv = document.getElementById('loading');

    function onResults(results) {
        loadingDiv.style.display = 'none';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];

            // åæ ‡æ˜ å°„
            const cx = (landmarks[0].x + landmarks[9].x) / 2;
            const cy = (landmarks[0].y + landmarks[9].y) / 2;
            handX = (1 - cx) * 2 - 1; 
            handY = -(cy * 2 - 1);

            // æåˆæ£€æµ‹
            const dx = landmarks[4].x - landmarks[8].x;
            const dy = landmarks[4].y - landmarks[8].y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            isPinching = dist < 0.05;

            // æ‰‹æŒ‡è®¡æ•°
            fingerCount = countFingers(landmarks);
            
            if (!isPinching) {
                currentShapeIndex = fingerCount;
            } else {
                currentShapeIndex = 0; // æåˆ = é»‘æ´
            }

            let shapeName = ["åç¼©å¥‡ç‚¹", "é“¶æ²³æ¼©æ¶¡", "æ— é™åŒç¯", "é‡å­è´è¶", "å…­ç“£ç«ç‘°", "å®‡å®™ä¹‹å¿ƒ"][currentShapeIndex] || "æœªçŸ¥";
            statusDiv.innerHTML = `æ‰‹æŒ‡: ${fingerCount} | å½¢æ€: ${shapeName}`;
            statusDiv.style.color = isPinching ? '#ff5555' : '#ffff00';

        } else {
            statusDiv.innerText = "å°†æ‰‹æŒæ”¾å…¥æ‘„åƒå¤´è§†é‡ä¸­...";
            isPinching = false;
        }
    }

    function countFingers(landmarks) {
        let count = 0;
        if (landmarks[8].y < landmarks[6].y) count++; 
        if (landmarks[12].y < landmarks[10].y) count++; 
        if (landmarks[16].y < landmarks[14].y) count++; 
        if (landmarks[20].y < landmarks[18].y) count++; 
        
        const thumbTip = landmarks[4];
        const indexBase = landmarks[5];
        const thumbBase = landmarks[2];
        if (Math.hypot(thumbTip.x - indexBase.x, thumbTip.y - indexBase.y) > 
            Math.hypot(thumbBase.x - indexBase.x, thumbBase.y - indexBase.y) * 1.2) {
            count++;
        }
        return count;
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
    hands.onResults(onResults);

    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => await hands.send({image: videoElement}),
        width: 640, height: 480
    });
    cameraUtils.start();

    // --- 5. åŠ¨ç”»å¾ªç¯ ---
    function animate() {
        requestAnimationFrame(animate);
        
        const time = Date.now() * 0.0005;

        // æ£€æµ‹å½¢æ€åˆ‡æ¢
        if (currentShapeIndex !== lastShapeIndex) {
            for (let i = 0; i < particleCount; i++) {
                const pos = getShapePos(currentShapeIndex, i);
                targetPositions[i * 3] = pos.x;
                targetPositions[i * 3 + 1] = pos.y;
                targetPositions[i * 3 + 2] = pos.z;
            }
            lastShapeIndex = currentShapeIndex;
            const audio = document.getElementById('bgm');
            if(audio.paused) audio.play().catch(e=>{});
        }

        const positionsAttribute = geometry.attributes.position;
        const colorsAttribute = geometry.attributes.color;

        // æ‰‹éƒ¨è·Ÿéš (å¸¦å¹³æ»‘)
        const targetX = handX * 800; 
        const targetY = handY * 600;

        for (let i = 0; i < particleCount; i++) {
            let px = positionsAttribute.array[i * 3];
            let py = positionsAttribute.array[i * 3 + 1];
            let pz = positionsAttribute.array[i * 3 + 2];

            let tx = targetPositions[i * 3];
            let ty = targetPositions[i * 3 + 1];
            let tz = targetPositions[i * 3 + 2];

            // æ ¸å¿ƒé€»è¾‘ï¼šç²’å­æµåŠ¨
            // æˆ‘ä»¬ä¸æ—‹è½¬æ•´ä¸ªç‰©ä½“ï¼Œè€Œæ˜¯æ”¹å˜ç²’å­çš„ç›®æ ‡ç´¢å¼•ï¼Œè®©ç²’å­æ²¿ç€å½¢çŠ¶"æµåŠ¨"
            // è¿™é‡Œä¸ºäº†ç®€å•å’Œæ€§èƒ½ï¼Œæˆ‘ä»¬ä¿æŒç²’å­åœ¨é™æ€å½¢çŠ¶ä¸Šå¾®åŠ¨ï¼Œä½†å½¢çŠ¶æœ¬èº«ç»å¯¹æ­£é¢
            
            if (isPinching) {
                // å¼ºåŠ›å¸å…¥
                tx = targetX + (Math.random()-0.5) * 50;
                ty = targetY + (Math.random()-0.5) * 50;
                tz = (Math.random()-0.5) * 50;
                px += (tx - px) * 0.1;
                py += (ty - py) * 0.1;
                pz += (tz - pz) * 0.1;
            } else {
                // è·Ÿéšæ‰‹éƒ¨å¹³ç§»
                tx += targetX;
                ty += targetY;
                
                // å¹³æ»‘é£å‘ç›®æ ‡
                px += (tx - px) * 0.05;
                py += (ty - py) * 0.05;
                pz += (tz - pz) * 0.05;
                
                // å¢åŠ ä¸€ç‚¹å¾®å°çš„ Z è½´èµ·ä¼ï¼Œæ¨¡æ‹Ÿå‘¼å¸æ„Ÿ
                pz += Math.sin(time * 2 + px * 0.01) * 0.5;
            }

            positionsAttribute.array[i * 3] = px;
            positionsAttribute.array[i * 3 + 1] = py;
            positionsAttribute.array[i * 3 + 2] = pz;

            // é¢œè‰²é€»è¾‘
            if (isPinching) {
                colorObj.setHSL(0.95, 0.9, 0.6); // çº¢è‰²è­¦æˆ’
            } else {
                // é¢œè‰²æ²¿Xè½´æ¸å˜ï¼Œå¢åŠ è§†è§‰å±‚æ¬¡
                const h = (time * 0.1 + (px + 1000)/2000 * 0.5) % 1;
                colorObj.setHSL(h, 0.8, 0.6);
            }
            colorsAttribute.array[i * 3] = colorObj.r;
            colorsAttribute.array[i * 3 + 1] = colorObj.g;
            colorsAttribute.array[i * 3 + 2] = colorObj.b;
        }

        positionsAttribute.needsUpdate = true;
        colorsAttribute.needsUpdate = true;

        // æ³¨æ„ï¼šç§»é™¤äº† particles.rotation.yï¼Œç¡®ä¿æ°¸è¿œæ­£é¢æœå‰
        // ä»…ä¿ç•™å¾®å°çš„è·Ÿéšé¼ æ ‡è§†å·®æ•ˆæœ (å¯é€‰)
        particles.rotation.x = -handY * 0.1; // è½»å¾®å€¾æ–œ
        particles.rotation.y = handX * 0.1;

        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>