<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>çµåŠ¨ç²’å­ï¼šè·Ÿéšä¸æŒæ§</title>
    <style>
        :root {
            --primary: #00f2ff;
            --bg-dark: #050505;
            --panel-bg: rgba(20, 20, 25, 0.7);
        }

        body {
            margin: 0; overflow: hidden; background: var(--bg-dark);
            font-family: 'Segoe UI', sans-serif; color: white;
        }

        #video-input { display: none; transform: scaleX(-1); } /* é•œåƒç¿»è½¬è§†é¢‘ */
        
        #canvas-container {
            position: absolute; width: 100%; height: 100%; z-index: 1;
            background: radial-gradient(circle at center, #1b1b2a 0%, #000 100%);
        }

        /* ç°ä»£ UI é¢æ¿ */
        #ui-panel {
            position: absolute; top: 20px; right: 20px; width: 240px;
            background: var(--panel-bg);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 12px; padding: 20px; z-index: 10;
            box-shadow: 0 8px 32px rgba(0,0,0,0.5);
        }

        h2 {
            margin: 0 0 15px 0; font-size: 14px; text-transform: uppercase;
            letter-spacing: 2px; color: var(--primary); text-align: center;
            border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 8px;
        }

        .btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 15px; }

        button {
            background: rgba(255,255,255,0.05); border: none; color: #ccc;
            padding: 8px; border-radius: 6px; cursor: pointer; transition: 0.2s;
            font-size: 12px;
        }
        button:hover { background: rgba(255,255,255,0.15); color: #fff; }
        button.active { background: var(--primary); color: #000; font-weight: bold; box-shadow: 0 0 10px var(--primary); }

        input[type="color"] { width: 100%; height: 30px; border: none; background: none; cursor: pointer; }

        #status {
            margin-top: 10px; padding: 10px; border-radius: 6px;
            background: rgba(0,0,0,0.3); font-size: 12px; text-align: center;
            border-left: 3px solid #555; transition: 0.3s;
        }

        /* åŠ è½½åŠ¨ç”» */
        #loader {
            position: fixed; inset: 0; background: #000; z-index: 100;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        .ring {
            width: 40px; height: 40px; border: 4px solid #333;
            border-top-color: var(--primary); border-radius: 50%;
            animation: spin 1s infinite linear;
        }
        @keyframes spin { 100% { transform: rotate(360deg); } }
    </style>

    <!-- ä¾èµ–åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
</head>
<body>

<div id="loader">
    <div class="ring"></div>
    <p style="color: #666; margin-top: 15px; font-size: 14px;">å¯åŠ¨è§†è§‰å¼•æ“...</p>
</div>

<div id="ui-panel">
    <h2>èƒ½é‡æ§åˆ¶å°</h2>
    <div class="btn-grid">
        <button onclick="changeShape('sphere')" class="active" id="btn-sphere">ğŸ”® çµçƒ</button>
        <button onclick="changeShape('heart')" id="btn-heart">â¤ï¸ å®ˆæŠ¤</button>
        <button onclick="changeShape('galaxy')" id="btn-galaxy">ğŸŒŒ æ˜Ÿæ—‹</button>
        <button onclick="changeShape('flower')" id="btn-flower">ğŸŒ¸ è²å</button>
        <button onclick="changeShape('cube')" id="btn-cube">ğŸ§Š çŸ©é˜µ</button>
        <button onclick="changeShape('dna')" id="btn-dna">ğŸ§¬ åŸºå› </button>
    </div>
    
    <div style="margin-bottom: 10px;">
        <label style="font-size:12px; opacity:0.7;">ç²’å­æµå…‰</label>
        <input type="color" id="colorPicker" value="#00f2ff">
    </div>

    <div id="status">ç­‰å¾…æ‰‹éƒ¨è¯†åˆ«...</div>
</div>

<video id="video-input"></video>
<div id="canvas-container"></div>

<script>
    // --- 1. Three.js åœºæ™¯æ­å»º ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.002);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 50; // æ‘„åƒæœºè·ç¦»

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    // --- 2. ç²’å­ç³»ç»Ÿæ•°æ®ç»“æ„ ---
    const count = 15000;
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(count * 3);
    
    // å­˜å‚¨æ¯ç§å½¢çŠ¶çš„ç›¸å¯¹åæ ‡ï¼ˆç›¸å¯¹äºæ‰‹å¿ƒï¼‰
    const shapes = {
        sphere: [], heart: [], galaxy: [], flower: [], cube: [], dna: []
    };
    // å­˜å‚¨éšæœºæ‰©æ•£å‘é‡ï¼ˆç”¨äºå¼ å¼€æ‰‹æ—¶ï¼‰
    const explosionDirs = new Float32Array(count * 3);

    // é¢„è®¡ç®—å„ç§å½¢çŠ¶æ•°æ®
    function initShapes() {
        const tempVec = new THREE.Vector3();
        
        for(let i=0; i<count; i++) {
            // 1. çƒä½“ (é»˜è®¤)
            getPointOnSphere(10, tempVec);
            shapes.sphere.push(tempVec.x, tempVec.y, tempVec.z);

            // 2. çˆ±å¿ƒ
            const t = Math.random() * Math.PI * 2;
            let x = 16 * Math.pow(Math.sin(t), 3);
            let y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
            let z = (Math.random() - 0.5) * 4;
            let s = 0.8 * Math.sqrt(Math.random()); // å¡«å……å†…éƒ¨
            shapes.heart.push(x*s, y*s + 2, z*s);

            // 3. æ˜Ÿæ—‹ (é“¶æ²³)
            const angle = Math.random() * Math.PI * 2 * 3; // 3åœˆ
            const radius = Math.random() * 20;
            shapes.galaxy.push(
                Math.cos(angle + radius * 0.2) * radius,
                (Math.random()-0.5) * 2,
                Math.sin(angle + radius * 0.2) * radius
            );

            // 4. èŠ±æœµ
            const u = Math.random() * Math.PI * 2;
            const v = Math.random() * Math.PI;
            const r = 10 + 4 * Math.cos(6 * u) * Math.sin(v);
            shapes.flower.push(
                r * Math.sin(v) * Math.cos(u),
                r * Math.sin(v) * Math.sin(u),
                r * Math.cos(v) * 0.3
            );

            // 5. ç«‹æ–¹ä½“
            const edge = 16;
            shapes.cube.push(
                (Math.random()-0.5) * edge,
                (Math.random()-0.5) * edge,
                (Math.random()-0.5) * edge
            );
            
            // 6. DNA åŒèºæ—‹
            const h = (Math.random() - 0.5) * 30; // é«˜åº¦
            const rot = h * 0.5;
            const offset = (i % 2 === 0) ? 0 : Math.PI; // åŒé“¾
            const w = 6;
            shapes.dna.push(
                Math.cos(rot + offset) * w + (Math.random()-0.5),
                h,
                Math.sin(rot + offset) * w + (Math.random()-0.5)
            );

            // åˆå§‹åŒ–çˆ†ç‚¸å‘é‡ (å•ä½çƒå‘é‡)
            getPointOnSphere(1, tempVec);
            explosionDirs[i*3] = tempVec.x;
            explosionDirs[i*3+1] = tempVec.y;
            explosionDirs[i*3+2] = tempVec.z;

            // åˆå§‹ä½ç½®è®¾ä¸º0
            positions[i*3] = 0;
            positions[i*3+1] = 0;
            positions[i*3+2] = 0;
        }
    }

    function getPointOnSphere(r, vec) {
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);
        vec.x = r * Math.sin(phi) * Math.cos(theta);
        vec.y = r * Math.sin(phi) * Math.sin(theta);
        vec.z = r * Math.cos(phi);
    }

    initShapes();
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

    // æè´¨
    const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/spark1.png');
    const material = new THREE.PointsMaterial({
        size: 0.8,
        color: 0x00f2ff,
        map: sprite,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
        depthWrite: false
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- 3. çŠ¶æ€ç®¡ç† ---
    let currentShapeData = shapes.sphere;
    let handWorldPos = new THREE.Vector3(0, 0, 0); // æ‰‹åœ¨3Dä¸–ç•Œçš„ä½ç½®
    let smoothedHandPos = new THREE.Vector3(0, 0, 0); // å¹³æ»‘åçš„ä½ç½®
    let handState = 0; // 0=å¼ å¼€(æ‰©æ•£), 1=æ¡æ‹³(èšæ‹¢)
    let isHandDetected = false;

    // UI åˆ‡æ¢å½¢çŠ¶
    window.changeShape = (name) => {
        currentShapeData = shapes[name];
        document.querySelectorAll('.btn-grid button').forEach(b => b.classList.remove('active'));
        document.getElementById('btn-'+name).classList.add('active');
    };

    // é¢œè‰²åˆ‡æ¢
    document.getElementById('colorPicker').addEventListener('input', (e) => {
        particles.material.color.set(e.target.value);
    });

    // --- 4. è§†è§‰ç®—æ³• (MediaPipe) ---
    const statusDiv = document.getElementById('status');
    const video = document.getElementById('video-input');

    function onResults(results) {
        document.getElementById('loader').style.display = 'none';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            isHandDetected = true;
            const landmarks = results.multiHandLandmarks[0];

            // 1. è®¡ç®—æ‰‹éƒ¨ä½ç½® (ä½¿ç”¨ä¸­æŒ‡æ ¹éƒ¨ 9 å’Œ æ‰‹è…• 0 çš„ä¸­é—´ç‚¹ä½œä¸ºæŒå¿ƒ)
            const palmX = landmarks[9].x;
            const palmY = landmarks[9].y;

            // æ˜ å°„åˆ° 3D ç©ºé—´ (ç®€å•çš„æŠ•å½±æ˜ å°„)
            // è§†å£å®½åº¦å¤§æ¦‚å¯¹åº”ä¸–ç•Œåæ ‡ x: -30 åˆ° 30, y: -20 åˆ° 20 (å–å†³äºç›¸æœºZ)
            // MediaPipe xæ˜¯ 0-1, æˆ‘ä»¬éœ€è¦ç¿»è½¬ x (é•œåƒ)
            const worldX = (0.5 - palmX) * 70; 
            const worldY = (0.5 - palmY) * 50;
            
            // æ›´æ–°ç›®æ ‡ä½ç½®
            handWorldPos.set(worldX, worldY, 0);

            // 2. è®¡ç®—å¼ åˆçŠ¶æ€ (æŒ‡å°–åˆ°æŒå¿ƒçš„å¹³å‡è·ç¦»)
            // æ‹‡æŒ‡(4), é£ŸæŒ‡(8), ä¸­æŒ‡(12), æ— å(16), å°æŒ‡(20) åˆ° æŒå¿ƒ(9)
            // ç®€åŒ–ï¼šåªè®¡ç®— æ‹‡æŒ‡å°–(4) å’Œ é£ŸæŒ‡å°–(8) çš„è·ç¦»æ¥åˆ¤æ–­æåˆ
            const d = Math.sqrt(
                Math.pow(landmarks[4].x - landmarks[8].x, 2) +
                Math.pow(landmarks[4].y - landmarks[8].y, 2)
            );

            // è·ç¦»é˜ˆå€¼è°ƒè¯•ï¼šé€šå¸¸æåˆ < 0.05, å¼ å¼€ > 0.1
            // æˆ‘ä»¬å¸Œæœ› handState: 1(èšæ‹¢), 0(æ‰©æ•£)
            // æ˜ å°„ï¼šd=0.03 -> State=1, d=0.15 -> State=0
            let rawState = (d - 0.03) / 0.12;
            rawState = 1.0 - Math.min(1, Math.max(0, rawState)); // åè½¬
            
            // å¹³æ»‘çŠ¶æ€å˜åŒ–
            handState += (rawState - handState) * 0.15;

            // UI åé¦ˆ
            if (handState > 0.6) {
                statusDiv.innerText = "âœŠ èƒ½é‡èšæ‹¢";
                statusDiv.style.borderLeftColor = "#00ff88";
                statusDiv.style.background = "rgba(0, 255, 136, 0.2)";
            } else {
                statusDiv.innerText = "ğŸ– èƒ½é‡é‡Šæ”¾";
                statusDiv.style.borderLeftColor = "#00f2ff";
                statusDiv.style.background = "rgba(0, 242, 255, 0.2)";
            }

        } else {
            isHandDetected = false;
            statusDiv.innerText = "ğŸ‘€ å¯»æ‰¾æ‰‹åŠ¿...";
            statusDiv.style.borderLeftColor = "#555";
            statusDiv.style.background = "rgba(0,0,0,0.3)";
            // æ— æ‰‹æ—¶ï¼Œè‡ªåŠ¨å›åˆ°ä¸­å¿ƒå¹¶ç¨å¾®æ‰©æ•£
            handWorldPos.set(0, 0, 0);
            handState += (0.2 - handState) * 0.05;
        }
    }

    // MediaPipe åˆå§‹åŒ–
    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
    });
    hands.onResults(onResults);

    const cam = new Camera(video, {
        onFrame: async () => await hands.send({image: video}),
        width: 640, height: 480
    });
    cam.start();

    // --- 5. åŠ¨ç”»å¾ªç¯ (æ ¸å¿ƒé€»è¾‘) ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);

        const time = clock.getElapsedTime();
        const posArr = particles.geometry.attributes.position.array;

        // 1. å¹³æ»‘æ‰‹éƒ¨ä½ç½® (æ’å€¼)
        smoothedHandPos.lerp(handWorldPos, 0.1);

        // æ—‹è½¬æ•´ä¸ªç³»ç»Ÿå¢åŠ åŠ¨æ„Ÿ
        particles.rotation.z = time * 0.05;

        // è®¡ç®—æ‰©æ•£ç³»æ•° (å¼ å¼€æ—¶å¤§ï¼Œæ¡æ‹³æ—¶å°)
        // handState: 1=èšæ‹¢, 0=å¼ å¼€
        // èšæ‹¢æ—¶ï¼šåç§»é‡ = 0ï¼Œå®Œå…¨ä½¿ç”¨å½¢çŠ¶æ•°æ®
        // å¼ å¼€æ—¶ï¼šåç§»é‡ = å¤§ï¼Œå½¢çŠ¶æ•°æ®è¢«è¦†ç›–æˆ–å åŠ 
        
        const spreadFactor = (1.0 - handState); 
        const explosionRadius = 25 * spreadFactor; // æ‰©æ•£åŠå¾„

        for(let i = 0; i < count; i++) {
            const ix = i * 3;
            const iy = i * 3 + 1;
            const iz = i * 3 + 2;

            // å½¢çŠ¶æœ¬èº«çš„åæ ‡
            const sx = currentShapeData[ix];
            const sy = currentShapeData[iy];
            const sz = currentShapeData[iz];

            // çˆ†ç‚¸æ–¹å‘ (å•ä½å‘é‡)
            const ex = explosionDirs[ix];
            const ey = explosionDirs[iy];
            const ez = explosionDirs[iz];

            // æ ¸å¿ƒè®¡ç®—å…¬å¼ï¼š
            // ç›®æ ‡ä½ç½® = æ‰‹å¿ƒä½ç½® + (å½¢çŠ¶åç§» * èšæ‹¢ç³»æ•°) + (çˆ†ç‚¸åç§» * æ‰©æ•£ç³»æ•°)
            
            // å½“ handState = 1 (èšæ‹¢):
            // Target = Hand + Shape * 1 + Explosion * 0  => å®Œç¾å½¢çŠ¶è·Ÿéšæ‰‹å¿ƒ
            
            // å½“ handState = 0 (å¼ å¼€):
            // Target = Hand + Shape * 0 + Explosion * Radius => å›´ç»•æ‰‹å¿ƒçš„å¤§çˆ†ç‚¸
            
            // ä¸ºäº†è¿‡æ¸¡æ›´è‡ªç„¶ï¼Œæˆ‘ä»¬å¯ä»¥æ··åˆä¸¤è€…
            const shapeWeight = handState; // 0~1
            const explodeWeight = (1.0 - handState); // 1~0
            
            // å¢åŠ ä¸€ç‚¹å™ªç‚¹è®©æ‰©æ•£æ›´ç”ŸåŠ¨
            const noise = Math.sin(time * 3 + i) * 2 * explodeWeight;

            const targetX = smoothedHandPos.x + (sx * shapeWeight) + (ex * explosionRadius) + (ex * noise);
            const targetY = smoothedHandPos.y + (sy * shapeWeight) + (ey * explosionRadius) + (ey * noise);
            const targetZ = smoothedHandPos.z + (sz * shapeWeight) + (ez * explosionRadius) + (ez * noise);

            // ç²’å­ç§»åŠ¨ (Lerp)
            posArr[ix] += (targetX - posArr[ix]) * 0.1;
            posArr[ix+1] += (targetY - posArr[iy]) * 0.1;
            posArr[ix+2] += (targetZ - posArr[iz]) * 0.1;
        }

        // åŠ¨æ€è°ƒæ•´ç²’å­å¤§å°ï¼šèšæ‹¢æ—¶å°è€Œç²¾ç»†ï¼Œæ‰©æ•£æ—¶å¤§è€Œæœ¦èƒ§
        material.size = 0.5 + (1.0 - handState) * 0.8;
        
        particles.geometry.attributes.position.needsUpdate = true;
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
</script>
</body>
</html>