<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Interactive Cosmic Math - Three.js</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; cursor: crosshair; }
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: rgba(100, 220, 255, 0.9);
            pointer-events: none;
            z-index: 10;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 15px #00eaff;
            mix-blend-mode: screen;
        }
        h1 { font-size: 1.4rem; margin: 0; letter-spacing: 6px; text-transform: uppercase; }
        p { font-size: 0.8rem; margin-top: 8px; color: rgba(255,255,255,0.6); }
        .instruction { font-size: 0.7rem; color: #ff00aa; margin-top: 5px; opacity: 0.8; }
    </style>
</head>
<body>

<div id="info">
    <h1 id="shape-name">COSMIC INTERACTION</h1>
    <p>Math x Chaos Particle System</p>
    <div class="instruction">[ 移动鼠标 ] 扰动星尘 &nbsp;|&nbsp; [ 点击长按 ] 制造奇点</div>
</div>

<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

// --- 配置参数 ---
const PARTICLE_COUNT = 100000; // 提升至10万粒子
const PARTICLE_SIZE = 1.5;
const TRANSITION_DURATION = 4.0;
const WAIT_TIME = 3.0;

// --- 全局变量 ---
let scene, camera, renderer, composer, controls;
let geometry, material, points;
let raycaster, interactionPlane;
let mouse = new THREE.Vector2(9999, 9999); // 初始在屏幕外
let targetMouseWorld = new THREE.Vector3();
let clock = new THREE.Clock();
let currentShapeIndex = 0;
let timeElapsed = 0;
let isTransitioning = false;
let isMouseDown = false;

// 形状数据
const shapes = [];
const shapeNames = [
    "洛伦兹吸引子 (Lorenz Attractor)",
    "克莱因瓶 (Klein Bottle)",
    "科赫分形体 (Koch Fractal)",
    "费马螺线 (Fermat Spiral)",
    "六瓣玫瑰 (Rose Surface)",
    "超环面 (Supertoroid)",
    "莫比乌斯环 (Möbius Strip)"
];

// --- 1. 初始化 ---
function init() {
    scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.0015);

    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 0, 90);

    renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.autoRotate = true;
    controls.autoRotateSpeed = 0.8;
    controls.enablePan = false;

    // --- 交互层 ---
    raycaster = new THREE.Raycaster();
    // 创建一个不可见的平面用于捕获鼠标在3D空间的位置
    interactionPlane = new THREE.Mesh(
        new THREE.PlaneGeometry(500, 500),
        new THREE.MeshBasicMaterial({ visible: false })
    );
    scene.add(interactionPlane);

    // --- 后处理 ---
    const renderScene = new RenderPass(scene, camera);
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
    bloomPass.threshold = 0.15;
    bloomPass.strength = 1.4;
    bloomPass.radius = 0.6;
    
    composer = new EffectComposer(renderer);
    composer.addPass(renderScene);
    composer.addPass(bloomPass);

    generateGeometries();
    createParticleSystem();
    
    // --- 事件监听 ---
    window.addEventListener('resize', onWindowResize);
    document.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mousedown', () => { isMouseDown = true; });
    document.addEventListener('mouseup', () => { isMouseDown = false; });
    // 移动端支持
    document.addEventListener('touchmove', onTouchMove, {passive: false});
    document.addEventListener('touchstart', () => { isMouseDown = true; });
    document.addEventListener('touchend', () => { isMouseDown = false; });

    animate();
}

// --- 2. 交互逻辑 ---
function onMouseMove(event) {
    // 归一化坐标 -1 到 1
    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
    mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
}

function onTouchMove(event) {
    if(event.touches.length > 0) {
        mouse.x = (event.touches[0].clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.touches[0].clientY / window.innerHeight) * 2 + 1;
    }
}

function updateInteraction() {
    // 1. 让交互平面始终面向摄像机 (Billboard)
    interactionPlane.lookAt(camera.position);
    
    // 2. 光线投射获取 3D 坐标
    raycaster.setFromCamera(mouse, camera);
    const intersects = raycaster.intersectObject(interactionPlane);
    
    if (intersects.length > 0) {
        // 让目标点稍微平滑移动
        targetMouseWorld.lerp(intersects[0].point, 0.2);
    } else {
        // 如果鼠标移出，归零或保持
        targetMouseWorld.lerp(new THREE.Vector3(999, 999, 999), 0.1);
    }

    // 3. 传递给 Shader
    material.uniforms.uMousePos.value.copy(targetMouseWorld);
    
    // 4. 点击交互强度插值
    const targetStrength = isMouseDown ? -40.0 : 15.0; // 点击时吸入(负值)或排斥更强，平时轻微排斥
    material.uniforms.uMouseStrength.value += (targetStrength - material.uniforms.uMouseStrength.value) * 0.1;
}

// --- 3. 高级数学形状生成 ---
function generateGeometries() {
    // Helper
    const addShape = (fn) => {
        const data = new Float32Array(PARTICLE_COUNT * 3);
        for(let i=0; i<PARTICLE_COUNT; i++) {
            const pt = fn(i, PARTICLE_COUNT);
            data[i*3] = pt.x;
            data[i*3+1] = pt.y;
            data[i*3+2] = pt.z;
        }
        shapes.push(data);
    };

    // A. 洛伦兹吸引子 (Lorenz) - 经典的混沌
    addShape((i, count) => {
        let x = 0.1, y = 0, z = 0;
        const dt = 0.005;
        const sigma = 10, rho = 28, beta = 8/3;
        // 预热迭代
        const startIter = i * 0.5; 
        for(let k=0; k < startIter + 100; k++) {
            let dx = sigma * (y - x) * dt;
            let dy = (x * (rho - z) - y) * dt;
            let dz = (x * y - beta * z) * dt;
            x += dx; y += dy; z += dz;
        }
        return {x: x*1.5, y: y*1.5 - 30, z: z*1.5 - 40}; // Centering
    });

    // B. 克莱因瓶 (Klein Bottle) - 拓扑美学
    addShape((i, count) => {
        const u = (i / count) * Math.PI * 2;
        const v = (i % 200) / 200 * Math.PI * 2;
        const r = 4 * (1 - Math.cos(u) / 2);
        let x, y, z;
        if (u < Math.PI) {
            x = 6 * Math.cos(u) * (1 + Math.sin(u)) + r * Math.cos(u) * Math.cos(v);
            y = 16 * Math.sin(u) + r * Math.sin(u) * Math.cos(v);
        } else {
            x = 6 * Math.cos(u) * (1 + Math.sin(u)) + r * Math.cos(v + Math.PI);
            y = 16 * Math.sin(u);
        }
        z = r * Math.sin(v);
        return {x: x*1.2, y: y*1.2, z: z*1.2};
    });

    // C. 科赫立体 (3D Koch Cloud)
    addShape((i, count) => {
        // 使用随机游走限制在四面体体积内模拟
        const r = 40 * Math.pow(Math.random(), 0.3);
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(2 * Math.random() - 1);
        // 增加分形噪声
        const noise = Math.sin(theta*10) * Math.cos(phi*10) * 5;
        return {
            x: (r+noise) * Math.sin(phi) * Math.cos(theta),
            y: (r+noise) * Math.sin(phi) * Math.sin(theta),
            z: (r+noise) * Math.cos(phi)
        };
    });

    // D. 费马螺线 (Fermat Sphere)
    addShape((i, count) => {
        const phi = Math.acos(-1 + (2 * i) / count);
        const theta = Math.sqrt(count * Math.PI) * phi;
        const r = 45;
        return {
            x: r * Math.sin(phi) * Math.cos(theta),
            y: r * Math.sin(phi) * Math.sin(theta),
            z: r * Math.cos(phi)
        };
    });

    // E. 玫瑰曲面 (Rose)
    addShape((i, count) => {
        const theta = Math.random() * Math.PI * 2;
        const phi = (i / count) * Math.PI * 2; // range
        const r = 30 + 10 * Math.cos(6 * theta) * Math.sin(3 * phi);
        return {
            x: r * Math.sin(phi) * Math.cos(theta),
            y: r * Math.cos(phi),
            z: r * Math.sin(phi) * Math.sin(theta)
        };
    });

    // F. 超环面 (Supertoroid)
    addShape((i, count) => {
        const u = (i/count) * Math.PI * 4;
        const v = (i % 100) / 100 * Math.PI * 2;
        const R = 30, r = 10;
        const t = 1.5, s = 1.5; // Exponents
        // x = sign(cosu) |cosu|^t * ...
        const sign = (val) => val > 0 ? 1 : (val < 0 ? -1 : 0);
        const pow = (val, p) => Math.pow(Math.abs(val), p);
        
        const cu = Math.cos(u), su = Math.sin(u);
        const cv = Math.cos(v), sv = Math.sin(v);
        
        const x = (R + r * sign(cv) * pow(cv, s)) * sign(cu) * pow(cu, t);
        const y = (R + r * sign(cv) * pow(cv, s)) * sign(su) * pow(su, t);
        const z = r * sign(sv) * pow(sv, s);
        return {x, y, z};
    });

    // G. 莫比乌斯环 (Mobius)
    addShape((i, count) => {
        const u = (i / count) * Math.PI * 2;
        const v = ((Math.random() - 0.5) * 20); // Width
        const scale = 2.5;
        const x = (1 + v/2 * Math.cos(u/2)) * Math.cos(u) * 20;
        const y = (1 + v/2 * Math.cos(u/2)) * Math.sin(u) * 20;
        const z = v/2 * Math.sin(u/2) * 20;
        return {x, z, y}; // rotate axis
    });
}

// --- 4. 粒子系统 & Shader ---
function createParticleSystem() {
    geometry = new THREE.BufferGeometry();
    const posAttribute = new THREE.BufferAttribute(new Float32Array(shapes[0]), 3);
    const targetAttribute = new THREE.BufferAttribute(new Float32Array(shapes[0]), 3); // Init with same
    
    // 颜色属性：基于位置计算渐变
    const colors = new Float32Array(PARTICLE_COUNT * 3);
    const c1 = new THREE.Color(0x00aaff);
    const c2 = new THREE.Color(0xff0055);
    for(let i=0; i<PARTICLE_COUNT; i++) {
        // 随机混合颜色
        const mixVal = Math.random();
        const c = c1.clone().lerp(c2, mixVal);
        colors[i*3] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
    }

    geometry.setAttribute('position', posAttribute);
    geometry.setAttribute('targetPosition', targetAttribute);
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    // --- 核心 Shader ---
    material = new THREE.ShaderMaterial({
        uniforms: {
            uTime: { value: 0 },
            uMix: { value: 0 },
            uSize: { value: PARTICLE_SIZE * window.devicePixelRatio },
            uMousePos: { value: new THREE.Vector3(999,999,999) }, // 鼠标3D位置
            uMouseStrength: { value: 0.0 } // 交互力度
        },
        vertexShader: `
            uniform float uTime;
            uniform float uMix;
            uniform float uSize;
            uniform vec3 uMousePos;
            uniform float uMouseStrength;

            attribute vec3 targetPosition;
            attribute vec3 color;
            
            varying vec3 vColor;
            varying float vDist; // 用于片元着色器调整亮度

            // 3D Simplex Noise (简化版)
            vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
            vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
            vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
            float snoise(vec3 v) { 
                const vec2  C = vec2(1.0/6.0, 1.0/3.0);
                const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
                // First corner
                vec3 i  = floor(v + dot(v, C.yyy) );
                vec3 x0 = v - i + dot(i, C.xxx) ;
                // Other corners
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy;
                vec3 x3 = x0 - D.yyy;
                // Permutations
                i = mod289(i); 
                vec4 p = permute( permute( permute( 
                            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                          + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) 
                          + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                // Gradients
                float n_ = 0.142857142857; // 1.0/7.0
                vec3  ns = n_ * D.wyz - D.xzx;
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ );
                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                // Normalise gradients
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                // Mix
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
            }

            // 三次缓动
            float cubicInOut(float t) {
                return t < 0.5 ? 4.0 * t * t * t : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;
            }

            void main() {
                vColor = color;
                
                // 1. 基础形态混合
                float t = cubicInOut(uMix);
                vec3 pos = mix(position, targetPosition, t);
                
                // 2. 交互物理场计算
                // 计算当前粒子到鼠标3D点的距离
                float d = distance(pos, uMousePos);
                
                // 定义影响半径
                float radius = 25.0; 
                
                if(d < radius) {
                    // 计算排斥/吸引向量
                    vec3 dir = normalize(pos - uMousePos);
                    
                    // 力的衰减：距离越近力越大
                    float force = (radius - d) / radius;
                    force = pow(force, 2.0) * uMouseStrength;
                    
                    // 应用力 (排斥: +dir, 吸引: -dir)
                    pos += dir * force;
                    
                    // 添加扰动噪声，模拟能量场的不稳定性
                    float noiseVal = snoise(pos * 0.1 + uTime);
                    pos += noiseVal * force * 0.2; 
                    
                    // 越近的粒子越亮
                    vColor += vec3(force * 0.05);
                }
                
                // 3. 全局自然律动 (呼吸)
                pos.x += sin(pos.y * 0.05 + uTime) * 0.2;
                pos.z += cos(pos.x * 0.05 + uTime) * 0.2;

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = uSize * (40.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
                
                vDist = d; // 传递距离给fragment
            }
        `,
        fragmentShader: `
            varying vec3 vColor;
            varying float vDist;
            
            void main() {
                // 圆形粒子
                vec2 center = gl_PointCoord - 0.5;
                float dist = length(center);
                if (dist > 0.5) discard;
                
                // 辉光核心
                float strength = 1.0 - smoothstep(0.0, 0.5, dist);
                
                // 交互高亮：如果粒子受到鼠标影响(vDist小)，增加白色hotspot
                vec3 finalColor = vColor;
                if(vDist < 25.0) {
                   finalColor += vec3(0.2, 0.2, 0.4) * (1.0 - vDist/25.0);
                }

                gl_FragColor = vec4(finalColor, strength * 0.8);
            }
        `,
        transparent: true,
        depthWrite: false,
        blending: THREE.AdditiveBlending
    });

    points = new THREE.Points(geometry, material);
    scene.add(points);
}

// --- 5. 动画循环 ---
function animate() {
    requestAnimationFrame(animate);

    const delta = clock.getDelta();
    timeElapsed += delta;
    
    // 持续旋转场景，但速度受鼠标交互影响
    // 如果正在点击交互，暂停旋转以便观察物理效果
    if (!isMouseDown) {
        points.rotation.y += 0.0015;
    }

    // 更新交互
    updateInteraction();
    
    material.uniforms.uTime.value = clock.getElapsedTime();

    // 自动形态切换逻辑
    if (!isTransitioning) {
        if (timeElapsed > WAIT_TIME) {
            isTransitioning = true;
            timeElapsed = 0;
            
            const nextIndex = (currentShapeIndex + 1) % shapes.length;
            
            // UI 更新
            const nameParts = shapeNames[nextIndex].split(' ');
            document.getElementById('shape-name').innerText = nameParts[0];
            
            // 切换 Buffer (CPU端设置起始和结束)
            geometry.attributes.position.array.set(shapes[currentShapeIndex]);
            geometry.attributes.targetPosition.array.set(shapes[nextIndex]);
            
            geometry.attributes.position.needsUpdate = true;
            geometry.attributes.targetPosition.needsUpdate = true;
            
            currentShapeIndex = nextIndex;
            material.uniforms.uMix.value = 0;
        }
    } else {
        const progress = Math.min(timeElapsed / TRANSITION_DURATION, 1.0);
        material.uniforms.uMix.value = progress;
        if (progress >= 1.0) {
            isTransitioning = false;
            timeElapsed = 0;
        }
    }

    controls.update();
    composer.render();
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
}

init();

</script>
</body>
</html>