<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>Cosmic Math Vortex - äº¤äº’å‡çº§ç‰ˆ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; touch-action: none; /* é˜²æ­¢æ‰‹æœºç«¯æ»šåŠ¨ */ }
        canvas { display: block; }
        #info {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255, 255, 255, 0.8);
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            pointer-events: none;
            z-index: 10;
            text-shadow: 0 0 10px #00ffff;
        }
        #current-shape {
            font-size: 24px;
            font-weight: bold;
            margin-top: 10px;
            text-shadow: 0 0 20px #ff00de;
        }
        #interaction-hint {
            font-size: 12px;
            margin-top: 5px;
            opacity: 0.7;
            color: #ffff00;
        }
        #music-control {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: white;
            z-index: 20;
            font-family: sans-serif;
            cursor: pointer;
            border: 1px solid white;
            padding: 10px;
            background: rgba(0,0,0,0.5);
            user-select: none;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

<div id="info">
    <div>COSMIC MATH VORTEX</div>
    <div id="current-shape">Chaos (Initial)</div>
    <div id="interaction-hint">ğŸ‘† æ‹–æ‹½æ—‹è½¬ | ğŸ–±ï¸ ç§»åŠ¨é¼ æ ‡/æ‰‹æŒ‡ä»¥æ­¤æ‰°åŠ¨æ˜Ÿå°˜</div>
</div>

<div id="music-control" onclick="toggleAudio()">ğŸµ æ’­æ”¾/æš‚åœ æ°›å›´éŸ³ä¹</div>

<audio id="bgm" loop>
    <source src="https://cdn.pixabay.com/download/audio/2022/03/10/audio_c8c8a73467.mp3?filename=cosmic-glow-14282.mp3" type="audio/mp3">
</audio>

<script>
    // --- 1. åˆå§‹åŒ–åœºæ™¯ ---
    const scene = new THREE.Scene();
    // å¢åŠ æ›´æµ“çš„è¿·é›¾ï¼Œå¢å¼ºæ·±ç©ºæ„Ÿ
    scene.fog = new THREE.FogExp2(0x000000, 0.0008); 

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 1, 20000);
    camera.position.z = 1200;
    camera.position.y = 300;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.05;
    controls.autoRotate = true; 
    controls.autoRotateSpeed = 0.8; // ç¨å¾®åŠ å¿«ä¸€ç‚¹æ—‹è½¬é€Ÿåº¦

    // --- 2. äº¤äº’ç³»ç»Ÿæ ¸å¿ƒå˜é‡ ---
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2(9999, 9999); // åˆå§‹ä½ç½®åœ¨å±å¹•å¤–
    const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0); // ç”¨äºè®¡ç®—é¼ æ ‡3Dæ·±åº¦çš„è™šæ‹Ÿå¹³é¢
    const planeNormal = new THREE.Vector3();
    const interactionTarget = new THREE.Vector3(); // é¼ æ ‡åœ¨3Dç©ºé—´çš„ä½ç½®

    // ç›‘å¬é¼ æ ‡/è§¦æ‘¸ç§»åŠ¨
    function onPointerMove(event) {
        event.preventDefault(); // é˜²æ­¢è§¦æ‘¸æ»šåŠ¨
        
        let clientX, clientY;
        if (event.changedTouches) {
            clientX = event.changedTouches[0].clientX;
            clientY = event.changedTouches[0].clientY;
        } else {
            clientX = event.clientX;
            clientY = event.clientY;
        }

        mouse.x = (clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(clientY / window.innerHeight) * 2 + 1;
    }

    window.addEventListener('mousemove', onPointerMove);
    window.addEventListener('touchmove', onPointerMove, { passive: false });
    window.addEventListener('touchstart', onPointerMove, { passive: false });


    // --- 3. åˆ›å»ºç²’å­ç³»ç»Ÿ ---
    const particleCount = 28000; // ç¨å¾®å¢åŠ ç²’å­æ•°
    const geometry = new THREE.BufferGeometry();
    
    const positions = new Float32Array(particleCount * 3);
    const targetPositions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    const colorObj = new THREE.Color();

    // åˆå§‹åŒ–ï¼šæ··æ²ŒçŠ¶æ€
    for (let i = 0; i < particleCount; i++) {
        const x = (Math.random() - 0.5) * 2500;
        const y = (Math.random() - 0.5) * 2500;
        const z = (Math.random() - 0.5) * 2500;

        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;

        targetPositions[i * 3] = x;
        targetPositions[i * 3 + 1] = y;
        targetPositions[i * 3 + 2] = z;

        colorObj.setHSL(Math.random(), 0.8, 0.5);
        colors[i * 3] = colorObj.r;
        colors[i * 3 + 1] = colorObj.g;
        colors[i * 3 + 2] = colorObj.b;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    // ç”Ÿæˆå‘å…‰è¾‰ç‚¹è´´å›¾ (æ›´é«˜è´¨é‡)
    function getTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64; 
        canvas.height = 64;
        const context = canvas.getContext('2d');
        const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
        gradient.addColorStop(0, 'rgba(255,255,255,1)');
        gradient.addColorStop(0.2, 'rgba(200,240,255,0.8)');
        gradient.addColorStop(0.5, 'rgba(60,150,255,0.3)');
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        context.fillStyle = gradient;
        context.fillRect(0, 0, 64, 64);
        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        return texture;
    }

    const material = new THREE.PointsMaterial({
        size: 10,
        map: getTexture(),
        vertexColors: true,
        blending: THREE.AdditiveBlending, // åŠ æ³•æ··åˆåˆ›é€ è¾‰å…‰
        depthWrite: false,
        transparent: true,
        opacity: 0.9
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- 4. æ•°å­¦å½¢æ€ç”Ÿæˆå™¨ ---
    function getShapePos(shapeType, i) {
        const t = (i / particleCount) * Math.PI * 2 * 10;
        
        let x = 0, y = 0, z = 0;

        switch (shapeType) {
            case 'Sphere (Chaos)':
                const r = 800 * Math.random();
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos((Math.random() * 2) - 1);
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta);
                z = r * Math.cos(phi);
                break;

            case 'Galaxy Spiral': // é“¶æ²³èºæ—‹
                const arms = 5;
                const spin = i * 0.005;
                const dist = i * 0.03;
                const armOffset = (i % arms) * (Math.PI * 2 / arms);
                x = dist * Math.cos(spin + armOffset) * 10;
                z = dist * Math.sin(spin + armOffset) * 10;
                y = (Math.random() - 0.5) * Math.sqrt(dist) * 20; 
                break;

            case 'Mobius Strip': // è«æ¯”ä¹Œæ–¯ç¯
                const u = (i / particleCount) * Math.PI * 2; // 0 to 2PI
                const v = (i % 200 / 200) * 2 - 1; // -1 to 1 width
                const radiusM = 400;
                x = (radiusM + v * 100 * Math.cos(u/2)) * Math.cos(u);
                y = (radiusM + v * 100 * Math.cos(u/2)) * Math.sin(u);
                z = v * 100 * Math.sin(u/2);
                break;

            case 'Heart Surface': // æ›´ç«‹ä½“çš„çˆ±å¿ƒ
                 const p1 = (i / particleCount) * Math.PI;
                 const p2 = (i % 100 / 100) * Math.PI * 2;
                 x = 10 * 16 * Math.pow(Math.sin(p1), 3) * Math.cos(p2);
                 z = 10 * 16 * Math.pow(Math.sin(p1), 3) * Math.sin(p2);
                 y = 10 * (13 * Math.cos(p1) - 5 * Math.cos(2*p1) - 2 * Math.cos(3*p1) - Math.cos(4*p1));
                 // æ—‹è½¬çˆ±å¿ƒä½¿å…¶ç›´ç«‹
                 const tempY = y; y = z; z = tempY; 
                 break;

            case 'Lissajous Knot': // å¤æ‚çš„æè¨å¦‚ç»“
                const s = i * 0.05;
                x = 300 * Math.sin(s * 3 + Math.PI/2);
                y = 300 * Math.sin(s * 4);
                z = 300 * Math.sin(s * 7);
                break;
                
            default: // é˜¿åŸºç±³å¾·èºæ—‹
                const rt = i * 0.05; 
                const angle = i * 0.01;
                x = rt * Math.cos(angle);
                z = rt * Math.sin(angle);
                y = (i - particleCount/2) * 0.1;
                break;
        }
        return {x, y, z};
    }

    const shapes = ['Sphere (Chaos)', 'Galaxy Spiral', 'Heart Surface', 'Mobius Strip', 'Lissajous Knot'];
    let currentShapeIndex = 0;
    
    function morphToNextShape() {
        currentShapeIndex = (currentShapeIndex + 1) % shapes.length;
        const shapeName = shapes[currentShapeIndex];
        
        const el = document.getElementById('current-shape');
        el.innerText = shapeName;
        // éšæœºéœ“è™¹è‰²
        el.style.color = `hsl(${Math.random() * 360}, 100%, 75%)`;
        el.style.textShadow = `0 0 20px ${el.style.color}`;

        for (let i = 0; i < particleCount; i++) {
            const pos = getShapePos(shapeName, i);
            targetPositions[i * 3] = pos.x;
            targetPositions[i * 3 + 1] = pos.y;
            targetPositions[i * 3 + 2] = pos.z;
        }
    }

    setInterval(morphToNextShape, 6000);

    // --- 5. åŠ¨ç”»å¾ªç¯ (å«ç‰©ç†å¼•æ“) ---
    const clock = new THREE.Clock();
    
    function animate() {
        requestAnimationFrame(animate);
        
        const time = Date.now() * 0.0005;
        const delta = clock.getDelta();

        // 1. è®¡ç®—é¼ æ ‡åœ¨3Dç©ºé—´çš„ä½ç½® (Interaction Point)
        // æˆ‘ä»¬å‡è®¾äº¤äº’å‘ç”Ÿåœ¨ä¸€ä¸ªæ€»æ˜¯é¢å‘æ‘„åƒæœºçš„å¹³é¢ä¸Šï¼Œå¹³é¢ç©¿è¿‡åœºæ™¯ä¸­å¿ƒ
        planeNormal.copy(camera.position).normalize();
        plane.normal.copy(planeNormal);
        raycaster.setFromCamera(mouse, camera);
        raycaster.ray.intersectPlane(plane, interactionTarget);

        const positionsAttribute = geometry.attributes.position;
        const colorsAttribute = geometry.attributes.color;

        for (let i = 0; i < particleCount; i++) {
            // è·å–å½“å‰åæ ‡
            let px = positionsAttribute.array[i * 3];
            let py = positionsAttribute.array[i * 3 + 1];
            let pz = positionsAttribute.array[i * 3 + 2];

            // è·å–ç›®æ ‡åæ ‡
            const tx = targetPositions[i * 3];
            const ty = targetPositions[i * 3 + 1];
            const tz = targetPositions[i * 3 + 2];

            // --- A. å½¢æ€å˜æ¢åŠ› (Spring Force) ---
            // ç²’å­æ€»æ˜¯è¯•å›¾å›åˆ°æ•°å­¦ç›®æ ‡ç‚¹
            // vx, vy, vz æ˜¯é€Ÿåº¦åˆ†é‡
            let vx = (tx - px) * 0.035; // 0.035 æ˜¯å›å½’å¼¹æ€§ç³»æ•°
            let vy = (ty - py) * 0.035;
            let vz = (tz - pz) * 0.035;

            // --- B. é¼ æ ‡æ–¥åŠ› (Repulsion Force) ---
            if (mouse.x !== 9999) { // åªæœ‰é¼ æ ‡åœ¨å±å¹•å†…æ‰è®¡ç®—
                const dx = px - interactionTarget.x;
                const dy = py - interactionTarget.y;
                const dz = pz - interactionTarget.z;

                const distSq = dx*dx + dy*dy + dz*dz;
                const radius = 350; // äº¤äº’åŠå¾„
                const radiusSq = radius * radius;

                if (distSq < radiusSq) {
                    const dist = Math.sqrt(distSq);
                    // åŠ›çš„å¤§å°ä¸è·ç¦»æˆåæ¯”ï¼šè¶Šè¿‘æ¨åŠ›è¶Šå¤§
                    const force = (radius - dist) / radius; 
                    const repulsionStrength = 30.0; // æ–¥åŠ›å¼ºåº¦

                    vx += (dx / dist) * force * repulsionStrength;
                    vy += (dy / dist) * force * repulsionStrength;
                    vz += (dz / dist) * force * repulsionStrength;
                }
            }

            // --- C. æ›´æ–°ä½ç½® ---
            positionsAttribute.array[i * 3] += vx;
            positionsAttribute.array[i * 3 + 1] += vy;
            positionsAttribute.array[i * 3 + 2] += vz;

            // --- D. é¢œè‰²æµè½¬ ---
            // æ ¹æ®è·ç¦»ä¸­å¿ƒçš„è¿œè¿‘å’Œæ—¶é—´æ”¹å˜é¢œè‰²
            const distFromCenter = Math.sqrt(px*px + py*py + pz*pz);
            const h = (time * 0.15 + distFromCenter * 0.0005) % 1; 
            const s = 0.8;
            const l = 0.6;
            
            colorObj.setHSL(h, s, l);
            colorsAttribute.array[i * 3] = colorObj.r;
            colorsAttribute.array[i * 3 + 1] = colorObj.g;
            colorsAttribute.array[i * 3 + 2] = colorObj.b;
        }

        positionsAttribute.needsUpdate = true;
        colorsAttribute.needsUpdate = true;

        // æ•´ä½“æ…¢é€Ÿæ—‹è½¬
        particles.rotation.y = time * 0.1;
        
        controls.update();
        renderer.render(scene, camera);
    }

    // çª—å£è°ƒæ•´
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();

    function toggleAudio() {
        const audio = document.getElementById('bgm');
        audio.paused ? audio.play() : audio.pause();
    }
</script>
</body>
</html>