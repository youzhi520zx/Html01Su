<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Cosmic Math Vortex - AI Hand Control</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', Courier, monospace; }
        canvas { display: block; }
        
        #ui-container {
            position: absolute;
            top: 20px;
            width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 10;
        }

        #title {
            color: rgba(255, 255, 255, 0.9);
            font-size: 18px;
            text-shadow: 0 0 10px #00ffff;
            margin-bottom: 10px;
        }

        #status {
            color: #ffff00;
            font-size: 14px;
            background: rgba(0,0,0,0.6);
            padding: 5px 10px;
            border-radius: 4px;
            display: inline-block;
        }

        #instruction {
            position: absolute;
            bottom: 20px;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.6);
            font-size: 12px;
            pointer-events: none;
        }
        
        /* éšè—åŸå§‹è§†é¢‘å…ƒç´ ï¼Œæˆ‘ä»¬åªç”¨å®ƒæ¥åšåˆ†æ */
        #input-video {
            display: none; 
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            animation: pulse 1s infinite;
            z-index: 100;
        }

        @keyframes pulse {
            0% { opacity: 0.5; }
            100% { opacity: 1; text-shadow: 0 0 20px cyan; }
        }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

<div id="loading" class="loading">æ­£åœ¨åˆå§‹åŒ– AI è§†è§‰æ ¸å¿ƒ...<br><span style="font-size:14px">è¯·å…è®¸æ‘„åƒå¤´æƒé™</span></div>

<div id="ui-container">
    <div id="title">COSMIC HAND CONTROL</div>
    <div id="status">ç­‰å¾…æ‰‹åŠ¿è¯†åˆ«...</div>
</div>

<div id="instruction">
    ğŸ–ï¸ 1-5æŒ‡åˆ‡æ¢å½¢æ€ | ğŸ‘Œ æåˆæ‰‹æŒ‡ç”Ÿæˆé»‘æ´ | ğŸ¤š ç§»åŠ¨æ‰‹æŒæ§åˆ¶å¼•åŠ›ä¸­å¿ƒ
</div>

<audio id="bgm" loop>
    <source src="https://cdn.pixabay.com/download/audio/2022/03/10/audio_c8c8a73467.mp3?filename=cosmic-glow-14282.mp3" type="audio/mp3">
</audio>

<video id="input-video"></video>

<script>
    // --- 1. Three.js åœºæ™¯åˆå§‹åŒ– ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.0006);

    const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 1, 20000);
    camera.position.z = 1000;
    camera.position.y = 0;

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    document.body.appendChild(renderer.domElement);

    // --- 2. ç²’å­ç³»ç»Ÿæ„å»º ---
    const particleCount = 20000; // ç²’å­æ•°é‡
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(particleCount * 3);
    const targetPositions = new Float32Array(particleCount * 3);
    const colors = new Float32Array(particleCount * 3);
    const colorObj = new THREE.Color();

    // åˆå§‹çŠ¶æ€ï¼šæ•£ä¹±
    for (let i = 0; i < particleCount; i++) {
        positions[i * 3] = (Math.random() - 0.5) * 2000;
        positions[i * 3 + 1] = (Math.random() - 0.5) * 2000;
        positions[i * 3 + 2] = (Math.random() - 0.5) * 2000;
        
        targetPositions[i] = positions[i]; // åˆå§‹ç›®æ ‡ç›¸åŒ

        colorObj.setHSL(Math.random(), 0.8, 0.5);
        colors[i * 3] = colorObj.r;
        colors[i * 3 + 1] = colorObj.g;
        colors[i * 3 + 2] = colorObj.b;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    // è¾‰å…‰æè´¨
    function getTexture() {
        const c = document.createElement('canvas');
        c.width = 32; c.height = 32;
        const ctx = c.getContext('2d');
        const g = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        g.addColorStop(0, 'rgba(255,255,255,1)');
        g.addColorStop(0.4, 'rgba(100,200,255,0.5)');
        g.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = g;
        ctx.fillRect(0,0,32,32);
        const t = new THREE.Texture(c);
        t.needsUpdate = true;
        return t;
    }

    const material = new THREE.PointsMaterial({
        size: 8,
        map: getTexture(),
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.8
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- 3. æ•°å­¦å½¢æ€ç”Ÿæˆåº“ ---
    function getShapePos(shapeIndex, i) {
        const t = (i / particleCount) * Math.PI * 2;
        let x=0, y=0, z=0;

        switch (shapeIndex) {
            case 0: // 0æŒ‡/æ‹³å¤´: é»‘æ´å¥‡ç‚¹ (Chaos Sphere)
                const r = 100 * Math.random(); 
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);
                x = r * Math.sin(phi) * Math.cos(theta);
                y = r * Math.sin(phi) * Math.sin(theta);
                z = r * Math.cos(phi);
                break;

            case 1: // 1æŒ‡: é˜¿åŸºç±³å¾·èºæ—‹ (Archimedean Spiral)
                const rt = i * 0.05; 
                const angle = i * 0.01;
                x = rt * Math.cos(angle);
                z = rt * Math.sin(angle);
                y = (i - particleCount/2) * 0.1;
                break;

            case 2: // 2æŒ‡: ä¼¯åŠªåˆ©åŒæ‰­çº¿ (Lemniscate / Infinity)
                const lt = t * 10;
                const scaleL = 500;
                const denom = 1 + Math.sin(lt) * Math.sin(lt);
                x = scaleL * Math.cos(lt) / denom;
                y = scaleL * Math.sin(lt) * Math.cos(lt) / denom;
                z = (i % 200 - 100) * 2; // åšåº¦
                break;
            
            case 3: // 3æŒ‡: è´è¶æ›²çº¿ (Butterfly)
                const bt = t * 12;
                const br = 150 * (Math.exp(Math.cos(bt)) - 2*Math.cos(4*bt) - Math.pow(Math.sin(bt/12),5));
                x = br * Math.sin(bt);
                y = br * Math.cos(bt);
                z = (Math.random()-0.5)*100;
                break;

            case 4: // 4æŒ‡: ç«ç‘°æ›²çº¿ (Rose Curve)
                const k = 4;
                const rr = 500 * Math.cos(k * t * 10);
                x = rr * Math.cos(t * 10);
                z = rr * Math.sin(t * 10);
                y = (Math.random() - 0.5) * 200;
                break;

            case 5: // 5æŒ‡: å¿ƒå½¢çº¿ (Cardioid Heart)
            default:
                const ct = t/2; 
                const cp = (i % 100)/100 * Math.PI * 2;
                x = 12 * 16 * Math.pow(Math.sin(ct), 3) * Math.cos(cp);
                z = 12 * 16 * Math.pow(Math.sin(ct), 3) * Math.sin(cp);
                y = 12 * (13 * Math.cos(ct) - 5 * Math.cos(2*ct) - 2 * Math.cos(3*ct) - Math.cos(4*ct));
                // æ—‹è½¬ä¸€ä¸‹è®©å®ƒæ­£å¯¹
                const temp = y; y = z; z = temp;
                break;
        }
        return {x, y, z};
    }

    // --- 4. æ‰‹åŠ¿æ§åˆ¶é€»è¾‘ (MediaPipe) ---
    let handX = 0, handY = 0; // æ‰‹éƒ¨ä¸­å¿ƒåæ ‡ (å½’ä¸€åŒ– -1 åˆ° 1)
    let isPinching = false;   // æ˜¯å¦æåˆ
    let fingerCount = 5;      // ä¼¸å‡ºçš„æ‰‹æŒ‡æ•°
    let currentShapeIndex = 5; // å½“å‰å±•ç¤ºçš„å½¢çŠ¶
    let lastShapeIndex = -1;  // ä¸Šä¸€æ¬¡çš„å½¢çŠ¶

    const videoElement = document.getElementById('input-video');
    const statusDiv = document.getElementById('status');
    const loadingDiv = document.getElementById('loading');

    function onResults(results) {
        // éšè—åŠ è½½åŠ¨ç”»
        loadingDiv.style.display = 'none';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];

            // 1. è®¡ç®—æ‰‹æŒä¸­å¿ƒ (ç”¨è…•éƒ¨(0)å’Œä¸­æŒ‡æ ¹éƒ¨(9)çš„å¹³å‡å€¼)
            // æ³¨æ„ï¼šMediaPipeçš„Xåæ ‡æ˜¯é•œåƒçš„ï¼Œä¸”èŒƒå›´æ˜¯0-1
            const cx = (landmarks[0].x + landmarks[9].x) / 2;
            const cy = (landmarks[0].y + landmarks[9].y) / 2;
            
            // æ˜ å°„åˆ° Three.js å±å¹•åæ ‡ (-1 åˆ° 1)
            // xéœ€è¦åè½¬ (1 - cx) æ‰èƒ½ç¬¦åˆé•œåƒä¹ æƒ¯
            handX = (1 - cx) * 2 - 1; 
            handY = -(cy * 2 - 1);

            // 2. æ£€æµ‹æåˆ (æ‹‡æŒ‡å°–(4) ä¸ é£ŸæŒ‡å°–(8) çš„è·ç¦»)
            const dx = landmarks[4].x - landmarks[8].x;
            const dy = landmarks[4].y - landmarks[8].y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            isPinching = dist < 0.05; // é˜ˆå€¼ï¼Œæ ¹æ®å®é™…æƒ…å†µè°ƒæ•´

            // 3. è®¡ç®—ä¼¸å‡ºçš„æ‰‹æŒ‡æ•°
            fingerCount = countFingers(landmarks);
            
            // å¦‚æœä¸æ˜¯æåˆçŠ¶æ€ï¼Œåˆ™æ ¹æ®æ‰‹æŒ‡æ•°é‡åˆ‡æ¢å½¢çŠ¶
            if (!isPinching) {
                currentShapeIndex = fingerCount;
            } else {
                currentShapeIndex = 0; // æåˆæ—¶å¼ºåˆ¶å˜ä¸ºæ··æ²Œ/å¥‡ç‚¹
            }

            // UI åé¦ˆ
            let shapeName = ["æ··æ²Œå¥‡ç‚¹ (é»‘æ´)", "é˜¿åŸºç±³å¾·èºæ—‹", "æ— é™åŒæ‰­çº¿", "è´è¶æ˜Ÿäº‘", "ç«ç‘°èŠ±ç¯", "çˆ±å¿ƒå®‡å®™"][currentShapeIndex] || "æœªçŸ¥";
            let action = isPinching ? "ã€å¼•åŠ›åç¼©ä¸­ã€‘" : "ã€å½¢æ€ç¨³å®šã€‘";
            statusDiv.innerHTML = `æ‰‹æŒ‡: ${fingerCount} | çŠ¶æ€: ${action} <br> å½¢æ€: ${shapeName}`;
            statusDiv.style.color = isPinching ? '#ff3333' : '#ffff00';

        } else {
            statusDiv.innerText = "æœªæ£€æµ‹åˆ°æ‰‹æŒ...";
            isPinching = false;
        }
    }

    function countFingers(landmarks) {
        let count = 0;
        // æ‹‡æŒ‡ (æ¯”è¾ƒxåæ ‡ï¼Œå› ä¸ºæ‹‡æŒ‡å…³èŠ‚è¿åŠ¨ä¸»è¦åœ¨xè½´ï¼Œéœ€åŒºåˆ†å·¦å³æ‰‹ï¼Œè¿™é‡Œç®€åŒ–å¤„ç†)
        // ç®€å•é€»è¾‘ï¼šå¦‚æœæ‹‡æŒ‡å°–(4)æ¯”å…³èŠ‚(3)ç¦»å°æŒ‡æ›´è¿œï¼Œåˆ™ç®—ä¼¸å‡ºã€‚
        // ä¸ºäº†ç®€åŒ–ï¼Œè¿™é‡Œä¸»è¦ç”¨é£ŸæŒ‡åˆ°å°æŒ‡çš„Yè½´åˆ¤æ–­ï¼ˆæ‰‹æŒå‘ä¸Šæ—¶ï¼‰
        // Tip (æŒ‡å°–) < PIP (ç¬¬äºŒå…³èŠ‚) æ„å‘³ç€æ‰‹æŒ‡ä¼¸ç›´ (Yè½´å‘ä¸‹å¢å¤§ï¼Œå±å¹•ä¸Šæ–¹Yå°)
        
        if (landmarks[8].y < landmarks[6].y) count++; // é£ŸæŒ‡
        if (landmarks[12].y < landmarks[10].y) count++; // ä¸­æŒ‡
        if (landmarks[16].y < landmarks[14].y) count++; // æ— åæŒ‡
        if (landmarks[20].y < landmarks[18].y) count++; // å°æŒ‡
        
        // æ‹‡æŒ‡æ¯”è¾ƒç‰¹æ®Šï¼Œç®€å•åˆ¤æ–­ï¼šæ‹‡æŒ‡å°–å’Œé£ŸæŒ‡æŒå…³èŠ‚çš„è·ç¦» vs æ‹‡æŒ‡å…³èŠ‚å’Œé£ŸæŒ‡æŒå…³èŠ‚
        // è¿™é‡Œåšä¸€ä¸ªç®€åŒ–çš„è·ç¦»åˆ¤æ–­
        const thumbTip = landmarks[4];
        const indexBase = landmarks[5];
        const thumbBase = landmarks[2];
        if (Math.hypot(thumbTip.x - indexBase.x, thumbTip.y - indexBase.y) > 
            Math.hypot(thumbBase.x - indexBase.x, thumbBase.y - indexBase.y) * 1.2) {
            count++;
        }
        
        return count;
    }

    // åˆå§‹åŒ– MediaPipe Hands
    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.6
    });

    hands.onResults(onResults);

    // å¯åŠ¨æ‘„åƒå¤´
    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 640,
        height: 480
    });
    cameraUtils.start();


    // --- 5. åŠ¨ç”»å¾ªç¯ä¸ç‰©ç†æ›´æ–° ---
    const clock = new THREE.Clock();

    function animate() {
        requestAnimationFrame(animate);
        
        const time = Date.now() * 0.0005;
        
        // 1. å¦‚æœå½¢çŠ¶æ”¹å˜ï¼Œæ›´æ–°æ‰€æœ‰ç²’å­çš„ç›®æ ‡ä½ç½®
        if (currentShapeIndex !== lastShapeIndex) {
            for (let i = 0; i < particleCount; i++) {
                const pos = getShapePos(currentShapeIndex, i);
                targetPositions[i * 3] = pos.x;
                targetPositions[i * 3 + 1] = pos.y;
                targetPositions[i * 3 + 2] = pos.z;
            }
            lastShapeIndex = currentShapeIndex;
            
            // æ’­æ”¾éŸ³ä¹ï¼ˆå¦‚æœæ˜¯ç¬¬ä¸€æ¬¡äº’åŠ¨ï¼‰
            const audio = document.getElementById('bgm');
            if(audio.paused) audio.play().catch(e=>{});
        }

        const positionsAttribute = geometry.attributes.position;
        const colorsAttribute = geometry.attributes.color;

        // æ‰‹æŒä½ç½®æ˜ å°„åˆ°3Dç©ºé—´èŒƒå›´
        const targetX = handX * 800; // æ”¾å¤§ç³»æ•°
        const targetY = handY * 600;

        for (let i = 0; i < particleCount; i++) {
            let px = positionsAttribute.array[i * 3];
            let py = positionsAttribute.array[i * 3 + 1];
            let pz = positionsAttribute.array[i * 3 + 2];

            // åŸºç¡€ç›®æ ‡ä½ç½®
            let tx = targetPositions[i * 3];
            let ty = targetPositions[i * 3 + 1];
            let tz = targetPositions[i * 3 + 2];

            // é€»è¾‘åˆ†æ”¯ï¼šæåˆ vs å±•å¼€
            if (isPinching) {
                // å¦‚æœæåˆï¼šæ‰€æœ‰ç²’å­å‘æ‰‹éƒ¨ä¸­å¿ƒåç¼© (é»‘æ´æ•ˆæœ)
                // åŠ ä¸Šä¸€ç‚¹éšæœºæŠ–åŠ¨æ¨¡æ‹Ÿä¸ç¨³å®šèƒ½é‡
                tx = targetX + (Math.random()-0.5) * 100;
                ty = targetY + (Math.random()-0.5) * 100;
                tz = (Math.random()-0.5) * 100;
                
                // åç¼©é€Ÿåº¦å¿«
                px += (tx - px) * 0.08;
                py += (ty - py) * 0.08;
                pz += (tz - pz) * 0.08;
            } else {
                // å¦‚æœå±•å¼€ï¼šç²’å­é£å‘æ•°å­¦å½¢çŠ¶çš„ç›®æ ‡ä½ç½®
                // ä½†æ˜¯å½¢çŠ¶æ•´ä½“è·Ÿéšæ‰‹éƒ¨ä½ç½®ç§»åŠ¨
                tx += targetX;
                ty += targetY;
                
                // å¹³æ»‘æ’å€¼ (Lerp)
                px += (tx - px) * 0.04;
                py += (ty - py) * 0.04;
                pz += (tz - pz) * 0.04;
            }

            positionsAttribute.array[i * 3] = px;
            positionsAttribute.array[i * 3 + 1] = py;
            positionsAttribute.array[i * 3 + 2] = pz;

            // é¢œè‰²åŠ¨æ€å˜åŒ–
            // æåˆæ—¶å˜çº¢/ç´«ï¼Œå¹³æ—¶æ ¹æ®æ—¶é—´æµè½¬
            if (isPinching) {
                colorObj.setHSL(0.95, 0.9, 0.6); // Red/Pink
            } else {
                const h = (time * 0.1 + i / particleCount * 0.2) % 1;
                colorObj.setHSL(h, 0.8, 0.6);
            }
            
            colorsAttribute.array[i * 3] = colorObj.r;
            colorsAttribute.array[i * 3 + 1] = colorObj.g;
            colorsAttribute.array[i * 3 + 2] = colorObj.b;
        }

        positionsAttribute.needsUpdate = true;
        colorsAttribute.needsUpdate = true;

        // ç¼“æ…¢æ—‹è½¬æ•´ä¸ªåœºæ™¯
        particles.rotation.y = time * 0.1;
        
        renderer.render(scene, camera);
    }

    // çª—å£è‡ªé€‚åº”
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();

</script>
</body>
</html>